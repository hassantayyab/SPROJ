Created by PLY version 3.10 (http://www.dabeaz.com/ply)

Unused terminals:

    ANDAND
    DIVIDE
    EQUALEQUAL
    FUNCTION
    GE
    GT
    LE
    LT
    MINUS
    NOT
    OROR
    PLUS
    RETURN
    TIMES
    NOTEQUAL
    STATEMENT
    SPACE
    INVERTED_COMMA
    PERCENTAGE

Grammar

Rule 0     S' -> program
Rule 1     program -> statement program
Rule 2     program -> <empty>
Rule 3     statements -> statement statements
Rule 4     statements -> <empty>
Rule 5     statement -> assignment
Rule 6     statement -> if
Rule 7     statement -> for
Rule 8     statement -> array
Rule 9     statement -> func
Rule 10    statement -> print
Rule 11    statement -> <empty>
Rule 12    func -> type IDENTIFIER LPAREN args RPAREN LBRACE RBRACE
Rule 13    args -> type IDENTIFIER COMMA args
Rule 14    args -> type IDENTIFIER
Rule 15    args -> <empty>
Rule 16    func -> type IDENTIFIER LPAREN args RPAREN LBRACE statements RBRACE
Rule 17    func -> IDENTIFIER LPAREN rec RPAREN SEMICOLON
Rule 18    rec -> exp
Rule 19    rec -> exp COMMA rec
Rule 20    rec -> <empty>
Rule 21    func -> type IDENTIFIER LPAREN RPAREN LBRACE statements RBRACE
Rule 22    assignment -> IDENTIFIER OPERATOR SEMICOLON
Rule 23    assignment -> IDENTIFIER EQUAL exp SEMICOLON
Rule 24    assignment -> type IDENTIFIER EQUAL exp SEMICOLON
Rule 25    assignment -> type IDENTIFIER SEMICOLON
Rule 26    if -> IF LPAREN exp_if RPAREN LBRACE statements RBRACE else_elseif
Rule 27    else_elseif -> elseif else_elseif
Rule 28    else_elseif -> else else_elseif
Rule 29    else_elseif -> <empty>
Rule 30    elseif -> ELSE IF LPAREN exp_if RPAREN LBRACE statements RBRACE
Rule 31    else -> ELSE LBRACE statements RBRACE
Rule 32    for -> FOR LPAREN exp_for RPAREN LBRACE statements RBRACE
Rule 33    exp_if -> IDENTIFIER
Rule 34    exp_if -> NUMBER
Rule 35    exp_if -> CHAR
Rule 36    exp_if -> exp_if RELATIONALOPERATOR exp_if
Rule 37    exp_for -> init exp_if SEMICOLON increment
Rule 38    init -> IDENTIFIER EQUAL exp SEMICOLON
Rule 39    init -> IDENTIFIER SEMICOLON
Rule 40    increment -> IDENTIFIER OPERATOR
Rule 41    increment -> IDENTIFIER EQUAL exp
Rule 42    exp -> IDENTIFIER
Rule 43    exp -> NUMBER
Rule 44    exp -> CHAR
Rule 45    exp -> TRUE
Rule 46    exp -> FALSE
Rule 47    exp -> IDENTIFIER LBRACK NUMBER RBRACK
Rule 48    exp -> IDENTIFIER LBRACK IDENTIFIER RBRACK
Rule 49    exp -> exp OPERATOR exp
Rule 50    exp -> exp OPERATOR
Rule 51    array -> type IDENTIFIER LBRACK NUMBER RBRACK SEMICOLON
Rule 52    array -> type IDENTIFIER LBRACK NUMBER RBRACK EQUAL LBRACE elements_array RBRACE SEMICOLON
Rule 53    array -> type IDENTIFIER LBRACK RBRACK EQUAL LBRACE elements_array RBRACE SEMICOLON
Rule 54    array -> IDENTIFIER LBRACK NUMBER RBRACK EQUAL exp SEMICOLON
Rule 55    array -> IDENTIFIER LBRACK IDENTIFIER RBRACK EQUAL exp SEMICOLON
Rule 56    elements_array -> NUMBER
Rule 57    elements_array -> CHAR
Rule 58    elements_array -> TRUE
Rule 59    elements_array -> FALSE
Rule 60    elements_array -> elements_array COMMA elements_array
Rule 61    elements_array -> <empty>
Rule 62    print -> PRINTF LPAREN STRING COMMA arguments RPAREN SEMICOLON
Rule 63    arguments -> exp
Rule 64    arguments -> exp COMMA arguments
Rule 65    arguments -> IDENTIFIER
Rule 66    arguments -> IDENTIFIER COMMA arguments
Rule 67    arguments -> <empty>
Rule 68    type -> INT
Rule 69    type -> DOUBLE
Rule 70    type -> CHARS
Rule 71    type -> STRINGS
Rule 72    type -> BOOL
Rule 73    type -> VOID

Terminals, with rules where they appear

ANDAND               : 
BOOL                 : 72
CHAR                 : 35 44 57
CHARS                : 70
COMMA                : 13 19 60 62 64 66
DIVIDE               : 
DOUBLE               : 69
ELSE                 : 30 31
EQUAL                : 23 24 38 41 52 53 54 55
EQUALEQUAL           : 
FALSE                : 46 59
FOR                  : 32
FUNCTION             : 
GE                   : 
GT                   : 
IDENTIFIER           : 12 13 14 16 17 21 22 23 24 25 33 38 39 40 41 42 47 48 48 51 52 53 54 55 55 65 66
IF                   : 26 30
INT                  : 68
INVERTED_COMMA       : 
LBRACE               : 12 16 21 26 30 31 32 52 53
LBRACK               : 47 48 51 52 53 54 55
LE                   : 
LPAREN               : 12 16 17 21 26 30 32 62
LT                   : 
MINUS                : 
NOT                  : 
NOTEQUAL             : 
NUMBER               : 34 43 47 51 52 54 56
OPERATOR             : 22 40 49 50
OROR                 : 
PERCENTAGE           : 
PLUS                 : 
PRINTF               : 62
RBRACE               : 12 16 21 26 30 31 32 52 53
RBRACK               : 47 48 51 52 53 54 55
RELATIONALOPERATOR   : 36
RETURN               : 
RPAREN               : 12 16 17 21 26 30 32 62
SEMICOLON            : 17 22 23 24 25 37 38 39 51 52 53 54 55 62
SPACE                : 
STATEMENT            : 
STRING               : 62
STRINGS              : 71
TIMES                : 
TRUE                 : 45 58
VOID                 : 73
error                : 

Nonterminals, with rules where they appear

args                 : 12 13 16
arguments            : 62 64 66
array                : 8
assignment           : 5
elements_array       : 52 53 60 60
else                 : 28
else_elseif          : 26 27 28
elseif               : 27
exp                  : 18 19 23 24 38 41 49 49 50 54 55 63 64
exp_for              : 32
exp_if               : 26 30 36 36 37
for                  : 7
func                 : 9
if                   : 6
increment            : 37
init                 : 37
print                : 10
program              : 1 0
rec                  : 17 19
statement            : 1 3
statements           : 3 16 21 26 30 31 32
type                 : 12 13 14 16 21 24 25 51 52 53

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . statement program
    (2) program -> .
    (5) statement -> . assignment
    (6) statement -> . if
    (7) statement -> . for
    (8) statement -> . array
    (9) statement -> . func
    (10) statement -> . print
    (11) statement -> .
    (22) assignment -> . IDENTIFIER OPERATOR SEMICOLON
    (23) assignment -> . IDENTIFIER EQUAL exp SEMICOLON
    (24) assignment -> . type IDENTIFIER EQUAL exp SEMICOLON
    (25) assignment -> . type IDENTIFIER SEMICOLON
    (26) if -> . IF LPAREN exp_if RPAREN LBRACE statements RBRACE else_elseif
    (32) for -> . FOR LPAREN exp_for RPAREN LBRACE statements RBRACE
    (51) array -> . type IDENTIFIER LBRACK NUMBER RBRACK SEMICOLON
    (52) array -> . type IDENTIFIER LBRACK NUMBER RBRACK EQUAL LBRACE elements_array RBRACE SEMICOLON
    (53) array -> . type IDENTIFIER LBRACK RBRACK EQUAL LBRACE elements_array RBRACE SEMICOLON
    (54) array -> . IDENTIFIER LBRACK NUMBER RBRACK EQUAL exp SEMICOLON
    (55) array -> . IDENTIFIER LBRACK IDENTIFIER RBRACK EQUAL exp SEMICOLON
    (12) func -> . type IDENTIFIER LPAREN args RPAREN LBRACE RBRACE
    (16) func -> . type IDENTIFIER LPAREN args RPAREN LBRACE statements RBRACE
    (17) func -> . IDENTIFIER LPAREN rec RPAREN SEMICOLON
    (21) func -> . type IDENTIFIER LPAREN RPAREN LBRACE statements RBRACE
    (62) print -> . PRINTF LPAREN STRING COMMA arguments RPAREN SEMICOLON
    (68) type -> . INT
    (69) type -> . DOUBLE
    (70) type -> . CHARS
    (71) type -> . STRINGS
    (72) type -> . BOOL
    (73) type -> . VOID

  ! reduce/reduce conflict for $end resolved using rule 2 (program -> .)
  ! shift/reduce conflict for IDENTIFIER resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for PRINTF resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for DOUBLE resolved as shift
  ! shift/reduce conflict for CHARS resolved as shift
  ! shift/reduce conflict for STRINGS resolved as shift
  ! shift/reduce conflict for BOOL resolved as shift
  ! shift/reduce conflict for VOID resolved as shift
    $end            reduce using rule 2 (program -> .)
    IDENTIFIER      shift and go to state 9
    IF              shift and go to state 11
    FOR             shift and go to state 12
    PRINTF          shift and go to state 13
    INT             shift and go to state 14
    DOUBLE          shift and go to state 15
    CHARS           shift and go to state 16
    STRINGS         shift and go to state 17
    BOOL            shift and go to state 18
    VOID            shift and go to state 19

  ! IDENTIFIER      [ reduce using rule 11 (statement -> .) ]
  ! IF              [ reduce using rule 11 (statement -> .) ]
  ! FOR             [ reduce using rule 11 (statement -> .) ]
  ! PRINTF          [ reduce using rule 11 (statement -> .) ]
  ! INT             [ reduce using rule 11 (statement -> .) ]
  ! DOUBLE          [ reduce using rule 11 (statement -> .) ]
  ! CHARS           [ reduce using rule 11 (statement -> .) ]
  ! STRINGS         [ reduce using rule 11 (statement -> .) ]
  ! BOOL            [ reduce using rule 11 (statement -> .) ]
  ! VOID            [ reduce using rule 11 (statement -> .) ]
  ! $end            [ reduce using rule 11 (statement -> .) ]

    program                        shift and go to state 1
    statement                      shift and go to state 2
    assignment                     shift and go to state 3
    if                             shift and go to state 4
    for                            shift and go to state 5
    array                          shift and go to state 6
    func                           shift and go to state 7
    print                          shift and go to state 8
    type                           shift and go to state 10

state 1

    (0) S' -> program .



state 2

    (1) program -> statement . program
    (1) program -> . statement program
    (2) program -> .
    (5) statement -> . assignment
    (6) statement -> . if
    (7) statement -> . for
    (8) statement -> . array
    (9) statement -> . func
    (10) statement -> . print
    (11) statement -> .
    (22) assignment -> . IDENTIFIER OPERATOR SEMICOLON
    (23) assignment -> . IDENTIFIER EQUAL exp SEMICOLON
    (24) assignment -> . type IDENTIFIER EQUAL exp SEMICOLON
    (25) assignment -> . type IDENTIFIER SEMICOLON
    (26) if -> . IF LPAREN exp_if RPAREN LBRACE statements RBRACE else_elseif
    (32) for -> . FOR LPAREN exp_for RPAREN LBRACE statements RBRACE
    (51) array -> . type IDENTIFIER LBRACK NUMBER RBRACK SEMICOLON
    (52) array -> . type IDENTIFIER LBRACK NUMBER RBRACK EQUAL LBRACE elements_array RBRACE SEMICOLON
    (53) array -> . type IDENTIFIER LBRACK RBRACK EQUAL LBRACE elements_array RBRACE SEMICOLON
    (54) array -> . IDENTIFIER LBRACK NUMBER RBRACK EQUAL exp SEMICOLON
    (55) array -> . IDENTIFIER LBRACK IDENTIFIER RBRACK EQUAL exp SEMICOLON
    (12) func -> . type IDENTIFIER LPAREN args RPAREN LBRACE RBRACE
    (16) func -> . type IDENTIFIER LPAREN args RPAREN LBRACE statements RBRACE
    (17) func -> . IDENTIFIER LPAREN rec RPAREN SEMICOLON
    (21) func -> . type IDENTIFIER LPAREN RPAREN LBRACE statements RBRACE
    (62) print -> . PRINTF LPAREN STRING COMMA arguments RPAREN SEMICOLON
    (68) type -> . INT
    (69) type -> . DOUBLE
    (70) type -> . CHARS
    (71) type -> . STRINGS
    (72) type -> . BOOL
    (73) type -> . VOID

  ! reduce/reduce conflict for $end resolved using rule 2 (program -> .)
  ! shift/reduce conflict for IDENTIFIER resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for PRINTF resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for DOUBLE resolved as shift
  ! shift/reduce conflict for CHARS resolved as shift
  ! shift/reduce conflict for STRINGS resolved as shift
  ! shift/reduce conflict for BOOL resolved as shift
  ! shift/reduce conflict for VOID resolved as shift
    $end            reduce using rule 2 (program -> .)
    IDENTIFIER      shift and go to state 9
    IF              shift and go to state 11
    FOR             shift and go to state 12
    PRINTF          shift and go to state 13
    INT             shift and go to state 14
    DOUBLE          shift and go to state 15
    CHARS           shift and go to state 16
    STRINGS         shift and go to state 17
    BOOL            shift and go to state 18
    VOID            shift and go to state 19

  ! IDENTIFIER      [ reduce using rule 11 (statement -> .) ]
  ! IF              [ reduce using rule 11 (statement -> .) ]
  ! FOR             [ reduce using rule 11 (statement -> .) ]
  ! PRINTF          [ reduce using rule 11 (statement -> .) ]
  ! INT             [ reduce using rule 11 (statement -> .) ]
  ! DOUBLE          [ reduce using rule 11 (statement -> .) ]
  ! CHARS           [ reduce using rule 11 (statement -> .) ]
  ! STRINGS         [ reduce using rule 11 (statement -> .) ]
  ! BOOL            [ reduce using rule 11 (statement -> .) ]
  ! VOID            [ reduce using rule 11 (statement -> .) ]
  ! $end            [ reduce using rule 11 (statement -> .) ]

    statement                      shift and go to state 2
    program                        shift and go to state 20
    assignment                     shift and go to state 3
    if                             shift and go to state 4
    for                            shift and go to state 5
    array                          shift and go to state 6
    func                           shift and go to state 7
    print                          shift and go to state 8
    type                           shift and go to state 10

state 3

    (5) statement -> assignment .

    IDENTIFIER      reduce using rule 5 (statement -> assignment .)
    IF              reduce using rule 5 (statement -> assignment .)
    FOR             reduce using rule 5 (statement -> assignment .)
    PRINTF          reduce using rule 5 (statement -> assignment .)
    INT             reduce using rule 5 (statement -> assignment .)
    DOUBLE          reduce using rule 5 (statement -> assignment .)
    CHARS           reduce using rule 5 (statement -> assignment .)
    STRINGS         reduce using rule 5 (statement -> assignment .)
    BOOL            reduce using rule 5 (statement -> assignment .)
    VOID            reduce using rule 5 (statement -> assignment .)
    $end            reduce using rule 5 (statement -> assignment .)
    RBRACE          reduce using rule 5 (statement -> assignment .)


state 4

    (6) statement -> if .

    IDENTIFIER      reduce using rule 6 (statement -> if .)
    IF              reduce using rule 6 (statement -> if .)
    FOR             reduce using rule 6 (statement -> if .)
    PRINTF          reduce using rule 6 (statement -> if .)
    INT             reduce using rule 6 (statement -> if .)
    DOUBLE          reduce using rule 6 (statement -> if .)
    CHARS           reduce using rule 6 (statement -> if .)
    STRINGS         reduce using rule 6 (statement -> if .)
    BOOL            reduce using rule 6 (statement -> if .)
    VOID            reduce using rule 6 (statement -> if .)
    $end            reduce using rule 6 (statement -> if .)
    RBRACE          reduce using rule 6 (statement -> if .)


state 5

    (7) statement -> for .

    IDENTIFIER      reduce using rule 7 (statement -> for .)
    IF              reduce using rule 7 (statement -> for .)
    FOR             reduce using rule 7 (statement -> for .)
    PRINTF          reduce using rule 7 (statement -> for .)
    INT             reduce using rule 7 (statement -> for .)
    DOUBLE          reduce using rule 7 (statement -> for .)
    CHARS           reduce using rule 7 (statement -> for .)
    STRINGS         reduce using rule 7 (statement -> for .)
    BOOL            reduce using rule 7 (statement -> for .)
    VOID            reduce using rule 7 (statement -> for .)
    $end            reduce using rule 7 (statement -> for .)
    RBRACE          reduce using rule 7 (statement -> for .)


state 6

    (8) statement -> array .

    IDENTIFIER      reduce using rule 8 (statement -> array .)
    IF              reduce using rule 8 (statement -> array .)
    FOR             reduce using rule 8 (statement -> array .)
    PRINTF          reduce using rule 8 (statement -> array .)
    INT             reduce using rule 8 (statement -> array .)
    DOUBLE          reduce using rule 8 (statement -> array .)
    CHARS           reduce using rule 8 (statement -> array .)
    STRINGS         reduce using rule 8 (statement -> array .)
    BOOL            reduce using rule 8 (statement -> array .)
    VOID            reduce using rule 8 (statement -> array .)
    $end            reduce using rule 8 (statement -> array .)
    RBRACE          reduce using rule 8 (statement -> array .)


state 7

    (9) statement -> func .

    IDENTIFIER      reduce using rule 9 (statement -> func .)
    IF              reduce using rule 9 (statement -> func .)
    FOR             reduce using rule 9 (statement -> func .)
    PRINTF          reduce using rule 9 (statement -> func .)
    INT             reduce using rule 9 (statement -> func .)
    DOUBLE          reduce using rule 9 (statement -> func .)
    CHARS           reduce using rule 9 (statement -> func .)
    STRINGS         reduce using rule 9 (statement -> func .)
    BOOL            reduce using rule 9 (statement -> func .)
    VOID            reduce using rule 9 (statement -> func .)
    $end            reduce using rule 9 (statement -> func .)
    RBRACE          reduce using rule 9 (statement -> func .)


state 8

    (10) statement -> print .

    IDENTIFIER      reduce using rule 10 (statement -> print .)
    IF              reduce using rule 10 (statement -> print .)
    FOR             reduce using rule 10 (statement -> print .)
    PRINTF          reduce using rule 10 (statement -> print .)
    INT             reduce using rule 10 (statement -> print .)
    DOUBLE          reduce using rule 10 (statement -> print .)
    CHARS           reduce using rule 10 (statement -> print .)
    STRINGS         reduce using rule 10 (statement -> print .)
    BOOL            reduce using rule 10 (statement -> print .)
    VOID            reduce using rule 10 (statement -> print .)
    $end            reduce using rule 10 (statement -> print .)
    RBRACE          reduce using rule 10 (statement -> print .)


state 9

    (22) assignment -> IDENTIFIER . OPERATOR SEMICOLON
    (23) assignment -> IDENTIFIER . EQUAL exp SEMICOLON
    (54) array -> IDENTIFIER . LBRACK NUMBER RBRACK EQUAL exp SEMICOLON
    (55) array -> IDENTIFIER . LBRACK IDENTIFIER RBRACK EQUAL exp SEMICOLON
    (17) func -> IDENTIFIER . LPAREN rec RPAREN SEMICOLON

    OPERATOR        shift and go to state 21
    EQUAL           shift and go to state 22
    LBRACK          shift and go to state 23
    LPAREN          shift and go to state 24


state 10

    (24) assignment -> type . IDENTIFIER EQUAL exp SEMICOLON
    (25) assignment -> type . IDENTIFIER SEMICOLON
    (51) array -> type . IDENTIFIER LBRACK NUMBER RBRACK SEMICOLON
    (52) array -> type . IDENTIFIER LBRACK NUMBER RBRACK EQUAL LBRACE elements_array RBRACE SEMICOLON
    (53) array -> type . IDENTIFIER LBRACK RBRACK EQUAL LBRACE elements_array RBRACE SEMICOLON
    (12) func -> type . IDENTIFIER LPAREN args RPAREN LBRACE RBRACE
    (16) func -> type . IDENTIFIER LPAREN args RPAREN LBRACE statements RBRACE
    (21) func -> type . IDENTIFIER LPAREN RPAREN LBRACE statements RBRACE

    IDENTIFIER      shift and go to state 25


state 11

    (26) if -> IF . LPAREN exp_if RPAREN LBRACE statements RBRACE else_elseif

    LPAREN          shift and go to state 26


state 12

    (32) for -> FOR . LPAREN exp_for RPAREN LBRACE statements RBRACE

    LPAREN          shift and go to state 27


state 13

    (62) print -> PRINTF . LPAREN STRING COMMA arguments RPAREN SEMICOLON

    LPAREN          shift and go to state 28


state 14

    (68) type -> INT .

    IDENTIFIER      reduce using rule 68 (type -> INT .)


state 15

    (69) type -> DOUBLE .

    IDENTIFIER      reduce using rule 69 (type -> DOUBLE .)


state 16

    (70) type -> CHARS .

    IDENTIFIER      reduce using rule 70 (type -> CHARS .)


state 17

    (71) type -> STRINGS .

    IDENTIFIER      reduce using rule 71 (type -> STRINGS .)


state 18

    (72) type -> BOOL .

    IDENTIFIER      reduce using rule 72 (type -> BOOL .)


state 19

    (73) type -> VOID .

    IDENTIFIER      reduce using rule 73 (type -> VOID .)


state 20

    (1) program -> statement program .

    $end            reduce using rule 1 (program -> statement program .)


state 21

    (22) assignment -> IDENTIFIER OPERATOR . SEMICOLON

    SEMICOLON       shift and go to state 29


state 22

    (23) assignment -> IDENTIFIER EQUAL . exp SEMICOLON
    (42) exp -> . IDENTIFIER
    (43) exp -> . NUMBER
    (44) exp -> . CHAR
    (45) exp -> . TRUE
    (46) exp -> . FALSE
    (47) exp -> . IDENTIFIER LBRACK NUMBER RBRACK
    (48) exp -> . IDENTIFIER LBRACK IDENTIFIER RBRACK
    (49) exp -> . exp OPERATOR exp
    (50) exp -> . exp OPERATOR

    IDENTIFIER      shift and go to state 30
    NUMBER          shift and go to state 32
    CHAR            shift and go to state 33
    TRUE            shift and go to state 34
    FALSE           shift and go to state 35

    exp                            shift and go to state 31

state 23

    (54) array -> IDENTIFIER LBRACK . NUMBER RBRACK EQUAL exp SEMICOLON
    (55) array -> IDENTIFIER LBRACK . IDENTIFIER RBRACK EQUAL exp SEMICOLON

    NUMBER          shift and go to state 37
    IDENTIFIER      shift and go to state 36


state 24

    (17) func -> IDENTIFIER LPAREN . rec RPAREN SEMICOLON
    (18) rec -> . exp
    (19) rec -> . exp COMMA rec
    (20) rec -> .
    (42) exp -> . IDENTIFIER
    (43) exp -> . NUMBER
    (44) exp -> . CHAR
    (45) exp -> . TRUE
    (46) exp -> . FALSE
    (47) exp -> . IDENTIFIER LBRACK NUMBER RBRACK
    (48) exp -> . IDENTIFIER LBRACK IDENTIFIER RBRACK
    (49) exp -> . exp OPERATOR exp
    (50) exp -> . exp OPERATOR

    RPAREN          reduce using rule 20 (rec -> .)
    IDENTIFIER      shift and go to state 30
    NUMBER          shift and go to state 32
    CHAR            shift and go to state 33
    TRUE            shift and go to state 34
    FALSE           shift and go to state 35

    rec                            shift and go to state 38
    exp                            shift and go to state 39

state 25

    (24) assignment -> type IDENTIFIER . EQUAL exp SEMICOLON
    (25) assignment -> type IDENTIFIER . SEMICOLON
    (51) array -> type IDENTIFIER . LBRACK NUMBER RBRACK SEMICOLON
    (52) array -> type IDENTIFIER . LBRACK NUMBER RBRACK EQUAL LBRACE elements_array RBRACE SEMICOLON
    (53) array -> type IDENTIFIER . LBRACK RBRACK EQUAL LBRACE elements_array RBRACE SEMICOLON
    (12) func -> type IDENTIFIER . LPAREN args RPAREN LBRACE RBRACE
    (16) func -> type IDENTIFIER . LPAREN args RPAREN LBRACE statements RBRACE
    (21) func -> type IDENTIFIER . LPAREN RPAREN LBRACE statements RBRACE

    EQUAL           shift and go to state 40
    SEMICOLON       shift and go to state 41
    LBRACK          shift and go to state 42
    LPAREN          shift and go to state 43


state 26

    (26) if -> IF LPAREN . exp_if RPAREN LBRACE statements RBRACE else_elseif
    (33) exp_if -> . IDENTIFIER
    (34) exp_if -> . NUMBER
    (35) exp_if -> . CHAR
    (36) exp_if -> . exp_if RELATIONALOPERATOR exp_if

    IDENTIFIER      shift and go to state 45
    NUMBER          shift and go to state 46
    CHAR            shift and go to state 47

    exp_if                         shift and go to state 44

state 27

    (32) for -> FOR LPAREN . exp_for RPAREN LBRACE statements RBRACE
    (37) exp_for -> . init exp_if SEMICOLON increment
    (38) init -> . IDENTIFIER EQUAL exp SEMICOLON
    (39) init -> . IDENTIFIER SEMICOLON

    IDENTIFIER      shift and go to state 50

    exp_for                        shift and go to state 48
    init                           shift and go to state 49

state 28

    (62) print -> PRINTF LPAREN . STRING COMMA arguments RPAREN SEMICOLON

    STRING          shift and go to state 51


state 29

    (22) assignment -> IDENTIFIER OPERATOR SEMICOLON .

    IDENTIFIER      reduce using rule 22 (assignment -> IDENTIFIER OPERATOR SEMICOLON .)
    IF              reduce using rule 22 (assignment -> IDENTIFIER OPERATOR SEMICOLON .)
    FOR             reduce using rule 22 (assignment -> IDENTIFIER OPERATOR SEMICOLON .)
    PRINTF          reduce using rule 22 (assignment -> IDENTIFIER OPERATOR SEMICOLON .)
    INT             reduce using rule 22 (assignment -> IDENTIFIER OPERATOR SEMICOLON .)
    DOUBLE          reduce using rule 22 (assignment -> IDENTIFIER OPERATOR SEMICOLON .)
    CHARS           reduce using rule 22 (assignment -> IDENTIFIER OPERATOR SEMICOLON .)
    STRINGS         reduce using rule 22 (assignment -> IDENTIFIER OPERATOR SEMICOLON .)
    BOOL            reduce using rule 22 (assignment -> IDENTIFIER OPERATOR SEMICOLON .)
    VOID            reduce using rule 22 (assignment -> IDENTIFIER OPERATOR SEMICOLON .)
    $end            reduce using rule 22 (assignment -> IDENTIFIER OPERATOR SEMICOLON .)
    RBRACE          reduce using rule 22 (assignment -> IDENTIFIER OPERATOR SEMICOLON .)


state 30

    (42) exp -> IDENTIFIER .
    (47) exp -> IDENTIFIER . LBRACK NUMBER RBRACK
    (48) exp -> IDENTIFIER . LBRACK IDENTIFIER RBRACK

    SEMICOLON       reduce using rule 42 (exp -> IDENTIFIER .)
    OPERATOR        reduce using rule 42 (exp -> IDENTIFIER .)
    COMMA           reduce using rule 42 (exp -> IDENTIFIER .)
    RPAREN          reduce using rule 42 (exp -> IDENTIFIER .)
    LBRACK          shift and go to state 52


state 31

    (23) assignment -> IDENTIFIER EQUAL exp . SEMICOLON
    (49) exp -> exp . OPERATOR exp
    (50) exp -> exp . OPERATOR

    SEMICOLON       shift and go to state 53
    OPERATOR        shift and go to state 54


state 32

    (43) exp -> NUMBER .

    SEMICOLON       reduce using rule 43 (exp -> NUMBER .)
    OPERATOR        reduce using rule 43 (exp -> NUMBER .)
    COMMA           reduce using rule 43 (exp -> NUMBER .)
    RPAREN          reduce using rule 43 (exp -> NUMBER .)


state 33

    (44) exp -> CHAR .

    SEMICOLON       reduce using rule 44 (exp -> CHAR .)
    OPERATOR        reduce using rule 44 (exp -> CHAR .)
    COMMA           reduce using rule 44 (exp -> CHAR .)
    RPAREN          reduce using rule 44 (exp -> CHAR .)


state 34

    (45) exp -> TRUE .

    SEMICOLON       reduce using rule 45 (exp -> TRUE .)
    OPERATOR        reduce using rule 45 (exp -> TRUE .)
    COMMA           reduce using rule 45 (exp -> TRUE .)
    RPAREN          reduce using rule 45 (exp -> TRUE .)


state 35

    (46) exp -> FALSE .

    SEMICOLON       reduce using rule 46 (exp -> FALSE .)
    OPERATOR        reduce using rule 46 (exp -> FALSE .)
    COMMA           reduce using rule 46 (exp -> FALSE .)
    RPAREN          reduce using rule 46 (exp -> FALSE .)


state 36

    (55) array -> IDENTIFIER LBRACK IDENTIFIER . RBRACK EQUAL exp SEMICOLON

    RBRACK          shift and go to state 55


state 37

    (54) array -> IDENTIFIER LBRACK NUMBER . RBRACK EQUAL exp SEMICOLON

    RBRACK          shift and go to state 56


state 38

    (17) func -> IDENTIFIER LPAREN rec . RPAREN SEMICOLON

    RPAREN          shift and go to state 57


state 39

    (18) rec -> exp .
    (19) rec -> exp . COMMA rec
    (49) exp -> exp . OPERATOR exp
    (50) exp -> exp . OPERATOR

    RPAREN          reduce using rule 18 (rec -> exp .)
    COMMA           shift and go to state 58
    OPERATOR        shift and go to state 54


state 40

    (24) assignment -> type IDENTIFIER EQUAL . exp SEMICOLON
    (42) exp -> . IDENTIFIER
    (43) exp -> . NUMBER
    (44) exp -> . CHAR
    (45) exp -> . TRUE
    (46) exp -> . FALSE
    (47) exp -> . IDENTIFIER LBRACK NUMBER RBRACK
    (48) exp -> . IDENTIFIER LBRACK IDENTIFIER RBRACK
    (49) exp -> . exp OPERATOR exp
    (50) exp -> . exp OPERATOR

    IDENTIFIER      shift and go to state 30
    NUMBER          shift and go to state 32
    CHAR            shift and go to state 33
    TRUE            shift and go to state 34
    FALSE           shift and go to state 35

    exp                            shift and go to state 59

state 41

    (25) assignment -> type IDENTIFIER SEMICOLON .

    IDENTIFIER      reduce using rule 25 (assignment -> type IDENTIFIER SEMICOLON .)
    IF              reduce using rule 25 (assignment -> type IDENTIFIER SEMICOLON .)
    FOR             reduce using rule 25 (assignment -> type IDENTIFIER SEMICOLON .)
    PRINTF          reduce using rule 25 (assignment -> type IDENTIFIER SEMICOLON .)
    INT             reduce using rule 25 (assignment -> type IDENTIFIER SEMICOLON .)
    DOUBLE          reduce using rule 25 (assignment -> type IDENTIFIER SEMICOLON .)
    CHARS           reduce using rule 25 (assignment -> type IDENTIFIER SEMICOLON .)
    STRINGS         reduce using rule 25 (assignment -> type IDENTIFIER SEMICOLON .)
    BOOL            reduce using rule 25 (assignment -> type IDENTIFIER SEMICOLON .)
    VOID            reduce using rule 25 (assignment -> type IDENTIFIER SEMICOLON .)
    $end            reduce using rule 25 (assignment -> type IDENTIFIER SEMICOLON .)
    RBRACE          reduce using rule 25 (assignment -> type IDENTIFIER SEMICOLON .)


state 42

    (51) array -> type IDENTIFIER LBRACK . NUMBER RBRACK SEMICOLON
    (52) array -> type IDENTIFIER LBRACK . NUMBER RBRACK EQUAL LBRACE elements_array RBRACE SEMICOLON
    (53) array -> type IDENTIFIER LBRACK . RBRACK EQUAL LBRACE elements_array RBRACE SEMICOLON

    NUMBER          shift and go to state 60
    RBRACK          shift and go to state 61


state 43

    (12) func -> type IDENTIFIER LPAREN . args RPAREN LBRACE RBRACE
    (16) func -> type IDENTIFIER LPAREN . args RPAREN LBRACE statements RBRACE
    (21) func -> type IDENTIFIER LPAREN . RPAREN LBRACE statements RBRACE
    (13) args -> . type IDENTIFIER COMMA args
    (14) args -> . type IDENTIFIER
    (15) args -> .
    (68) type -> . INT
    (69) type -> . DOUBLE
    (70) type -> . CHARS
    (71) type -> . STRINGS
    (72) type -> . BOOL
    (73) type -> . VOID

  ! shift/reduce conflict for RPAREN resolved as shift
    RPAREN          shift and go to state 64
    INT             shift and go to state 14
    DOUBLE          shift and go to state 15
    CHARS           shift and go to state 16
    STRINGS         shift and go to state 17
    BOOL            shift and go to state 18
    VOID            shift and go to state 19

  ! RPAREN          [ reduce using rule 15 (args -> .) ]

    type                           shift and go to state 62
    args                           shift and go to state 63

state 44

    (26) if -> IF LPAREN exp_if . RPAREN LBRACE statements RBRACE else_elseif
    (36) exp_if -> exp_if . RELATIONALOPERATOR exp_if

    RPAREN          shift and go to state 65
    RELATIONALOPERATOR shift and go to state 66


state 45

    (33) exp_if -> IDENTIFIER .

    RPAREN          reduce using rule 33 (exp_if -> IDENTIFIER .)
    RELATIONALOPERATOR reduce using rule 33 (exp_if -> IDENTIFIER .)
    SEMICOLON       reduce using rule 33 (exp_if -> IDENTIFIER .)


state 46

    (34) exp_if -> NUMBER .

    RPAREN          reduce using rule 34 (exp_if -> NUMBER .)
    RELATIONALOPERATOR reduce using rule 34 (exp_if -> NUMBER .)
    SEMICOLON       reduce using rule 34 (exp_if -> NUMBER .)


state 47

    (35) exp_if -> CHAR .

    RPAREN          reduce using rule 35 (exp_if -> CHAR .)
    RELATIONALOPERATOR reduce using rule 35 (exp_if -> CHAR .)
    SEMICOLON       reduce using rule 35 (exp_if -> CHAR .)


state 48

    (32) for -> FOR LPAREN exp_for . RPAREN LBRACE statements RBRACE

    RPAREN          shift and go to state 67


state 49

    (37) exp_for -> init . exp_if SEMICOLON increment
    (33) exp_if -> . IDENTIFIER
    (34) exp_if -> . NUMBER
    (35) exp_if -> . CHAR
    (36) exp_if -> . exp_if RELATIONALOPERATOR exp_if

    IDENTIFIER      shift and go to state 45
    NUMBER          shift and go to state 46
    CHAR            shift and go to state 47

    exp_if                         shift and go to state 68

state 50

    (38) init -> IDENTIFIER . EQUAL exp SEMICOLON
    (39) init -> IDENTIFIER . SEMICOLON

    EQUAL           shift and go to state 69
    SEMICOLON       shift and go to state 70


state 51

    (62) print -> PRINTF LPAREN STRING . COMMA arguments RPAREN SEMICOLON

    COMMA           shift and go to state 71


state 52

    (47) exp -> IDENTIFIER LBRACK . NUMBER RBRACK
    (48) exp -> IDENTIFIER LBRACK . IDENTIFIER RBRACK

    NUMBER          shift and go to state 73
    IDENTIFIER      shift and go to state 72


state 53

    (23) assignment -> IDENTIFIER EQUAL exp SEMICOLON .

    IDENTIFIER      reduce using rule 23 (assignment -> IDENTIFIER EQUAL exp SEMICOLON .)
    IF              reduce using rule 23 (assignment -> IDENTIFIER EQUAL exp SEMICOLON .)
    FOR             reduce using rule 23 (assignment -> IDENTIFIER EQUAL exp SEMICOLON .)
    PRINTF          reduce using rule 23 (assignment -> IDENTIFIER EQUAL exp SEMICOLON .)
    INT             reduce using rule 23 (assignment -> IDENTIFIER EQUAL exp SEMICOLON .)
    DOUBLE          reduce using rule 23 (assignment -> IDENTIFIER EQUAL exp SEMICOLON .)
    CHARS           reduce using rule 23 (assignment -> IDENTIFIER EQUAL exp SEMICOLON .)
    STRINGS         reduce using rule 23 (assignment -> IDENTIFIER EQUAL exp SEMICOLON .)
    BOOL            reduce using rule 23 (assignment -> IDENTIFIER EQUAL exp SEMICOLON .)
    VOID            reduce using rule 23 (assignment -> IDENTIFIER EQUAL exp SEMICOLON .)
    $end            reduce using rule 23 (assignment -> IDENTIFIER EQUAL exp SEMICOLON .)
    RBRACE          reduce using rule 23 (assignment -> IDENTIFIER EQUAL exp SEMICOLON .)


state 54

    (49) exp -> exp OPERATOR . exp
    (50) exp -> exp OPERATOR .
    (42) exp -> . IDENTIFIER
    (43) exp -> . NUMBER
    (44) exp -> . CHAR
    (45) exp -> . TRUE
    (46) exp -> . FALSE
    (47) exp -> . IDENTIFIER LBRACK NUMBER RBRACK
    (48) exp -> . IDENTIFIER LBRACK IDENTIFIER RBRACK
    (49) exp -> . exp OPERATOR exp
    (50) exp -> . exp OPERATOR

    SEMICOLON       reduce using rule 50 (exp -> exp OPERATOR .)
    OPERATOR        reduce using rule 50 (exp -> exp OPERATOR .)
    COMMA           reduce using rule 50 (exp -> exp OPERATOR .)
    RPAREN          reduce using rule 50 (exp -> exp OPERATOR .)
    IDENTIFIER      shift and go to state 30
    NUMBER          shift and go to state 32
    CHAR            shift and go to state 33
    TRUE            shift and go to state 34
    FALSE           shift and go to state 35

    exp                            shift and go to state 74

state 55

    (55) array -> IDENTIFIER LBRACK IDENTIFIER RBRACK . EQUAL exp SEMICOLON

    EQUAL           shift and go to state 75


state 56

    (54) array -> IDENTIFIER LBRACK NUMBER RBRACK . EQUAL exp SEMICOLON

    EQUAL           shift and go to state 76


state 57

    (17) func -> IDENTIFIER LPAREN rec RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 77


state 58

    (19) rec -> exp COMMA . rec
    (18) rec -> . exp
    (19) rec -> . exp COMMA rec
    (20) rec -> .
    (42) exp -> . IDENTIFIER
    (43) exp -> . NUMBER
    (44) exp -> . CHAR
    (45) exp -> . TRUE
    (46) exp -> . FALSE
    (47) exp -> . IDENTIFIER LBRACK NUMBER RBRACK
    (48) exp -> . IDENTIFIER LBRACK IDENTIFIER RBRACK
    (49) exp -> . exp OPERATOR exp
    (50) exp -> . exp OPERATOR

    RPAREN          reduce using rule 20 (rec -> .)
    IDENTIFIER      shift and go to state 30
    NUMBER          shift and go to state 32
    CHAR            shift and go to state 33
    TRUE            shift and go to state 34
    FALSE           shift and go to state 35

    exp                            shift and go to state 39
    rec                            shift and go to state 78

state 59

    (24) assignment -> type IDENTIFIER EQUAL exp . SEMICOLON
    (49) exp -> exp . OPERATOR exp
    (50) exp -> exp . OPERATOR

    SEMICOLON       shift and go to state 79
    OPERATOR        shift and go to state 54


state 60

    (51) array -> type IDENTIFIER LBRACK NUMBER . RBRACK SEMICOLON
    (52) array -> type IDENTIFIER LBRACK NUMBER . RBRACK EQUAL LBRACE elements_array RBRACE SEMICOLON

    RBRACK          shift and go to state 80


state 61

    (53) array -> type IDENTIFIER LBRACK RBRACK . EQUAL LBRACE elements_array RBRACE SEMICOLON

    EQUAL           shift and go to state 81


state 62

    (13) args -> type . IDENTIFIER COMMA args
    (14) args -> type . IDENTIFIER

    IDENTIFIER      shift and go to state 82


state 63

    (12) func -> type IDENTIFIER LPAREN args . RPAREN LBRACE RBRACE
    (16) func -> type IDENTIFIER LPAREN args . RPAREN LBRACE statements RBRACE

    RPAREN          shift and go to state 83


state 64

    (21) func -> type IDENTIFIER LPAREN RPAREN . LBRACE statements RBRACE

    LBRACE          shift and go to state 84


state 65

    (26) if -> IF LPAREN exp_if RPAREN . LBRACE statements RBRACE else_elseif

    LBRACE          shift and go to state 85


state 66

    (36) exp_if -> exp_if RELATIONALOPERATOR . exp_if
    (33) exp_if -> . IDENTIFIER
    (34) exp_if -> . NUMBER
    (35) exp_if -> . CHAR
    (36) exp_if -> . exp_if RELATIONALOPERATOR exp_if

    IDENTIFIER      shift and go to state 45
    NUMBER          shift and go to state 46
    CHAR            shift and go to state 47

    exp_if                         shift and go to state 86

state 67

    (32) for -> FOR LPAREN exp_for RPAREN . LBRACE statements RBRACE

    LBRACE          shift and go to state 87


state 68

    (37) exp_for -> init exp_if . SEMICOLON increment
    (36) exp_if -> exp_if . RELATIONALOPERATOR exp_if

    SEMICOLON       shift and go to state 88
    RELATIONALOPERATOR shift and go to state 66


state 69

    (38) init -> IDENTIFIER EQUAL . exp SEMICOLON
    (42) exp -> . IDENTIFIER
    (43) exp -> . NUMBER
    (44) exp -> . CHAR
    (45) exp -> . TRUE
    (46) exp -> . FALSE
    (47) exp -> . IDENTIFIER LBRACK NUMBER RBRACK
    (48) exp -> . IDENTIFIER LBRACK IDENTIFIER RBRACK
    (49) exp -> . exp OPERATOR exp
    (50) exp -> . exp OPERATOR

    IDENTIFIER      shift and go to state 30
    NUMBER          shift and go to state 32
    CHAR            shift and go to state 33
    TRUE            shift and go to state 34
    FALSE           shift and go to state 35

    exp                            shift and go to state 89

state 70

    (39) init -> IDENTIFIER SEMICOLON .

    IDENTIFIER      reduce using rule 39 (init -> IDENTIFIER SEMICOLON .)
    NUMBER          reduce using rule 39 (init -> IDENTIFIER SEMICOLON .)
    CHAR            reduce using rule 39 (init -> IDENTIFIER SEMICOLON .)


state 71

    (62) print -> PRINTF LPAREN STRING COMMA . arguments RPAREN SEMICOLON
    (63) arguments -> . exp
    (64) arguments -> . exp COMMA arguments
    (65) arguments -> . IDENTIFIER
    (66) arguments -> . IDENTIFIER COMMA arguments
    (67) arguments -> .
    (42) exp -> . IDENTIFIER
    (43) exp -> . NUMBER
    (44) exp -> . CHAR
    (45) exp -> . TRUE
    (46) exp -> . FALSE
    (47) exp -> . IDENTIFIER LBRACK NUMBER RBRACK
    (48) exp -> . IDENTIFIER LBRACK IDENTIFIER RBRACK
    (49) exp -> . exp OPERATOR exp
    (50) exp -> . exp OPERATOR

    IDENTIFIER      shift and go to state 92
    RPAREN          reduce using rule 67 (arguments -> .)
    NUMBER          shift and go to state 32
    CHAR            shift and go to state 33
    TRUE            shift and go to state 34
    FALSE           shift and go to state 35

    arguments                      shift and go to state 90
    exp                            shift and go to state 91

state 72

    (48) exp -> IDENTIFIER LBRACK IDENTIFIER . RBRACK

    RBRACK          shift and go to state 93


state 73

    (47) exp -> IDENTIFIER LBRACK NUMBER . RBRACK

    RBRACK          shift and go to state 94


state 74

    (49) exp -> exp OPERATOR exp .
    (49) exp -> exp . OPERATOR exp
    (50) exp -> exp . OPERATOR

  ! shift/reduce conflict for OPERATOR resolved as shift
    SEMICOLON       reduce using rule 49 (exp -> exp OPERATOR exp .)
    COMMA           reduce using rule 49 (exp -> exp OPERATOR exp .)
    RPAREN          reduce using rule 49 (exp -> exp OPERATOR exp .)
    OPERATOR        shift and go to state 54

  ! OPERATOR        [ reduce using rule 49 (exp -> exp OPERATOR exp .) ]


state 75

    (55) array -> IDENTIFIER LBRACK IDENTIFIER RBRACK EQUAL . exp SEMICOLON
    (42) exp -> . IDENTIFIER
    (43) exp -> . NUMBER
    (44) exp -> . CHAR
    (45) exp -> . TRUE
    (46) exp -> . FALSE
    (47) exp -> . IDENTIFIER LBRACK NUMBER RBRACK
    (48) exp -> . IDENTIFIER LBRACK IDENTIFIER RBRACK
    (49) exp -> . exp OPERATOR exp
    (50) exp -> . exp OPERATOR

    IDENTIFIER      shift and go to state 30
    NUMBER          shift and go to state 32
    CHAR            shift and go to state 33
    TRUE            shift and go to state 34
    FALSE           shift and go to state 35

    exp                            shift and go to state 95

state 76

    (54) array -> IDENTIFIER LBRACK NUMBER RBRACK EQUAL . exp SEMICOLON
    (42) exp -> . IDENTIFIER
    (43) exp -> . NUMBER
    (44) exp -> . CHAR
    (45) exp -> . TRUE
    (46) exp -> . FALSE
    (47) exp -> . IDENTIFIER LBRACK NUMBER RBRACK
    (48) exp -> . IDENTIFIER LBRACK IDENTIFIER RBRACK
    (49) exp -> . exp OPERATOR exp
    (50) exp -> . exp OPERATOR

    IDENTIFIER      shift and go to state 30
    NUMBER          shift and go to state 32
    CHAR            shift and go to state 33
    TRUE            shift and go to state 34
    FALSE           shift and go to state 35

    exp                            shift and go to state 96

state 77

    (17) func -> IDENTIFIER LPAREN rec RPAREN SEMICOLON .

    IDENTIFIER      reduce using rule 17 (func -> IDENTIFIER LPAREN rec RPAREN SEMICOLON .)
    IF              reduce using rule 17 (func -> IDENTIFIER LPAREN rec RPAREN SEMICOLON .)
    FOR             reduce using rule 17 (func -> IDENTIFIER LPAREN rec RPAREN SEMICOLON .)
    PRINTF          reduce using rule 17 (func -> IDENTIFIER LPAREN rec RPAREN SEMICOLON .)
    INT             reduce using rule 17 (func -> IDENTIFIER LPAREN rec RPAREN SEMICOLON .)
    DOUBLE          reduce using rule 17 (func -> IDENTIFIER LPAREN rec RPAREN SEMICOLON .)
    CHARS           reduce using rule 17 (func -> IDENTIFIER LPAREN rec RPAREN SEMICOLON .)
    STRINGS         reduce using rule 17 (func -> IDENTIFIER LPAREN rec RPAREN SEMICOLON .)
    BOOL            reduce using rule 17 (func -> IDENTIFIER LPAREN rec RPAREN SEMICOLON .)
    VOID            reduce using rule 17 (func -> IDENTIFIER LPAREN rec RPAREN SEMICOLON .)
    $end            reduce using rule 17 (func -> IDENTIFIER LPAREN rec RPAREN SEMICOLON .)
    RBRACE          reduce using rule 17 (func -> IDENTIFIER LPAREN rec RPAREN SEMICOLON .)


state 78

    (19) rec -> exp COMMA rec .

    RPAREN          reduce using rule 19 (rec -> exp COMMA rec .)


state 79

    (24) assignment -> type IDENTIFIER EQUAL exp SEMICOLON .

    IDENTIFIER      reduce using rule 24 (assignment -> type IDENTIFIER EQUAL exp SEMICOLON .)
    IF              reduce using rule 24 (assignment -> type IDENTIFIER EQUAL exp SEMICOLON .)
    FOR             reduce using rule 24 (assignment -> type IDENTIFIER EQUAL exp SEMICOLON .)
    PRINTF          reduce using rule 24 (assignment -> type IDENTIFIER EQUAL exp SEMICOLON .)
    INT             reduce using rule 24 (assignment -> type IDENTIFIER EQUAL exp SEMICOLON .)
    DOUBLE          reduce using rule 24 (assignment -> type IDENTIFIER EQUAL exp SEMICOLON .)
    CHARS           reduce using rule 24 (assignment -> type IDENTIFIER EQUAL exp SEMICOLON .)
    STRINGS         reduce using rule 24 (assignment -> type IDENTIFIER EQUAL exp SEMICOLON .)
    BOOL            reduce using rule 24 (assignment -> type IDENTIFIER EQUAL exp SEMICOLON .)
    VOID            reduce using rule 24 (assignment -> type IDENTIFIER EQUAL exp SEMICOLON .)
    $end            reduce using rule 24 (assignment -> type IDENTIFIER EQUAL exp SEMICOLON .)
    RBRACE          reduce using rule 24 (assignment -> type IDENTIFIER EQUAL exp SEMICOLON .)


state 80

    (51) array -> type IDENTIFIER LBRACK NUMBER RBRACK . SEMICOLON
    (52) array -> type IDENTIFIER LBRACK NUMBER RBRACK . EQUAL LBRACE elements_array RBRACE SEMICOLON

    SEMICOLON       shift and go to state 97
    EQUAL           shift and go to state 98


state 81

    (53) array -> type IDENTIFIER LBRACK RBRACK EQUAL . LBRACE elements_array RBRACE SEMICOLON

    LBRACE          shift and go to state 99


state 82

    (13) args -> type IDENTIFIER . COMMA args
    (14) args -> type IDENTIFIER .

    COMMA           shift and go to state 100
    RPAREN          reduce using rule 14 (args -> type IDENTIFIER .)


state 83

    (12) func -> type IDENTIFIER LPAREN args RPAREN . LBRACE RBRACE
    (16) func -> type IDENTIFIER LPAREN args RPAREN . LBRACE statements RBRACE

    LBRACE          shift and go to state 101


state 84

    (21) func -> type IDENTIFIER LPAREN RPAREN LBRACE . statements RBRACE
    (3) statements -> . statement statements
    (4) statements -> .
    (5) statement -> . assignment
    (6) statement -> . if
    (7) statement -> . for
    (8) statement -> . array
    (9) statement -> . func
    (10) statement -> . print
    (11) statement -> .
    (22) assignment -> . IDENTIFIER OPERATOR SEMICOLON
    (23) assignment -> . IDENTIFIER EQUAL exp SEMICOLON
    (24) assignment -> . type IDENTIFIER EQUAL exp SEMICOLON
    (25) assignment -> . type IDENTIFIER SEMICOLON
    (26) if -> . IF LPAREN exp_if RPAREN LBRACE statements RBRACE else_elseif
    (32) for -> . FOR LPAREN exp_for RPAREN LBRACE statements RBRACE
    (51) array -> . type IDENTIFIER LBRACK NUMBER RBRACK SEMICOLON
    (52) array -> . type IDENTIFIER LBRACK NUMBER RBRACK EQUAL LBRACE elements_array RBRACE SEMICOLON
    (53) array -> . type IDENTIFIER LBRACK RBRACK EQUAL LBRACE elements_array RBRACE SEMICOLON
    (54) array -> . IDENTIFIER LBRACK NUMBER RBRACK EQUAL exp SEMICOLON
    (55) array -> . IDENTIFIER LBRACK IDENTIFIER RBRACK EQUAL exp SEMICOLON
    (12) func -> . type IDENTIFIER LPAREN args RPAREN LBRACE RBRACE
    (16) func -> . type IDENTIFIER LPAREN args RPAREN LBRACE statements RBRACE
    (17) func -> . IDENTIFIER LPAREN rec RPAREN SEMICOLON
    (21) func -> . type IDENTIFIER LPAREN RPAREN LBRACE statements RBRACE
    (62) print -> . PRINTF LPAREN STRING COMMA arguments RPAREN SEMICOLON
    (68) type -> . INT
    (69) type -> . DOUBLE
    (70) type -> . CHARS
    (71) type -> . STRINGS
    (72) type -> . BOOL
    (73) type -> . VOID

  ! reduce/reduce conflict for RBRACE resolved using rule 4 (statements -> .)
  ! shift/reduce conflict for IDENTIFIER resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for PRINTF resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for DOUBLE resolved as shift
  ! shift/reduce conflict for CHARS resolved as shift
  ! shift/reduce conflict for STRINGS resolved as shift
  ! shift/reduce conflict for BOOL resolved as shift
  ! shift/reduce conflict for VOID resolved as shift
    RBRACE          reduce using rule 4 (statements -> .)
    IDENTIFIER      shift and go to state 9
    IF              shift and go to state 11
    FOR             shift and go to state 12
    PRINTF          shift and go to state 13
    INT             shift and go to state 14
    DOUBLE          shift and go to state 15
    CHARS           shift and go to state 16
    STRINGS         shift and go to state 17
    BOOL            shift and go to state 18
    VOID            shift and go to state 19

  ! IDENTIFIER      [ reduce using rule 11 (statement -> .) ]
  ! IF              [ reduce using rule 11 (statement -> .) ]
  ! FOR             [ reduce using rule 11 (statement -> .) ]
  ! PRINTF          [ reduce using rule 11 (statement -> .) ]
  ! INT             [ reduce using rule 11 (statement -> .) ]
  ! DOUBLE          [ reduce using rule 11 (statement -> .) ]
  ! CHARS           [ reduce using rule 11 (statement -> .) ]
  ! STRINGS         [ reduce using rule 11 (statement -> .) ]
  ! BOOL            [ reduce using rule 11 (statement -> .) ]
  ! VOID            [ reduce using rule 11 (statement -> .) ]
  ! RBRACE          [ reduce using rule 11 (statement -> .) ]

    type                           shift and go to state 10
    statements                     shift and go to state 102
    statement                      shift and go to state 103
    assignment                     shift and go to state 3
    if                             shift and go to state 4
    for                            shift and go to state 5
    array                          shift and go to state 6
    func                           shift and go to state 7
    print                          shift and go to state 8

state 85

    (26) if -> IF LPAREN exp_if RPAREN LBRACE . statements RBRACE else_elseif
    (3) statements -> . statement statements
    (4) statements -> .
    (5) statement -> . assignment
    (6) statement -> . if
    (7) statement -> . for
    (8) statement -> . array
    (9) statement -> . func
    (10) statement -> . print
    (11) statement -> .
    (22) assignment -> . IDENTIFIER OPERATOR SEMICOLON
    (23) assignment -> . IDENTIFIER EQUAL exp SEMICOLON
    (24) assignment -> . type IDENTIFIER EQUAL exp SEMICOLON
    (25) assignment -> . type IDENTIFIER SEMICOLON
    (26) if -> . IF LPAREN exp_if RPAREN LBRACE statements RBRACE else_elseif
    (32) for -> . FOR LPAREN exp_for RPAREN LBRACE statements RBRACE
    (51) array -> . type IDENTIFIER LBRACK NUMBER RBRACK SEMICOLON
    (52) array -> . type IDENTIFIER LBRACK NUMBER RBRACK EQUAL LBRACE elements_array RBRACE SEMICOLON
    (53) array -> . type IDENTIFIER LBRACK RBRACK EQUAL LBRACE elements_array RBRACE SEMICOLON
    (54) array -> . IDENTIFIER LBRACK NUMBER RBRACK EQUAL exp SEMICOLON
    (55) array -> . IDENTIFIER LBRACK IDENTIFIER RBRACK EQUAL exp SEMICOLON
    (12) func -> . type IDENTIFIER LPAREN args RPAREN LBRACE RBRACE
    (16) func -> . type IDENTIFIER LPAREN args RPAREN LBRACE statements RBRACE
    (17) func -> . IDENTIFIER LPAREN rec RPAREN SEMICOLON
    (21) func -> . type IDENTIFIER LPAREN RPAREN LBRACE statements RBRACE
    (62) print -> . PRINTF LPAREN STRING COMMA arguments RPAREN SEMICOLON
    (68) type -> . INT
    (69) type -> . DOUBLE
    (70) type -> . CHARS
    (71) type -> . STRINGS
    (72) type -> . BOOL
    (73) type -> . VOID

  ! reduce/reduce conflict for RBRACE resolved using rule 4 (statements -> .)
  ! shift/reduce conflict for IDENTIFIER resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for PRINTF resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for DOUBLE resolved as shift
  ! shift/reduce conflict for CHARS resolved as shift
  ! shift/reduce conflict for STRINGS resolved as shift
  ! shift/reduce conflict for BOOL resolved as shift
  ! shift/reduce conflict for VOID resolved as shift
    RBRACE          reduce using rule 4 (statements -> .)
    IDENTIFIER      shift and go to state 9
    IF              shift and go to state 11
    FOR             shift and go to state 12
    PRINTF          shift and go to state 13
    INT             shift and go to state 14
    DOUBLE          shift and go to state 15
    CHARS           shift and go to state 16
    STRINGS         shift and go to state 17
    BOOL            shift and go to state 18
    VOID            shift and go to state 19

  ! IDENTIFIER      [ reduce using rule 11 (statement -> .) ]
  ! IF              [ reduce using rule 11 (statement -> .) ]
  ! FOR             [ reduce using rule 11 (statement -> .) ]
  ! PRINTF          [ reduce using rule 11 (statement -> .) ]
  ! INT             [ reduce using rule 11 (statement -> .) ]
  ! DOUBLE          [ reduce using rule 11 (statement -> .) ]
  ! CHARS           [ reduce using rule 11 (statement -> .) ]
  ! STRINGS         [ reduce using rule 11 (statement -> .) ]
  ! BOOL            [ reduce using rule 11 (statement -> .) ]
  ! VOID            [ reduce using rule 11 (statement -> .) ]
  ! RBRACE          [ reduce using rule 11 (statement -> .) ]

    statements                     shift and go to state 104
    statement                      shift and go to state 103
    assignment                     shift and go to state 3
    if                             shift and go to state 4
    for                            shift and go to state 5
    array                          shift and go to state 6
    func                           shift and go to state 7
    print                          shift and go to state 8
    type                           shift and go to state 10

state 86

    (36) exp_if -> exp_if RELATIONALOPERATOR exp_if .
    (36) exp_if -> exp_if . RELATIONALOPERATOR exp_if

  ! shift/reduce conflict for RELATIONALOPERATOR resolved as shift
    RPAREN          reduce using rule 36 (exp_if -> exp_if RELATIONALOPERATOR exp_if .)
    SEMICOLON       reduce using rule 36 (exp_if -> exp_if RELATIONALOPERATOR exp_if .)
    RELATIONALOPERATOR shift and go to state 66

  ! RELATIONALOPERATOR [ reduce using rule 36 (exp_if -> exp_if RELATIONALOPERATOR exp_if .) ]


state 87

    (32) for -> FOR LPAREN exp_for RPAREN LBRACE . statements RBRACE
    (3) statements -> . statement statements
    (4) statements -> .
    (5) statement -> . assignment
    (6) statement -> . if
    (7) statement -> . for
    (8) statement -> . array
    (9) statement -> . func
    (10) statement -> . print
    (11) statement -> .
    (22) assignment -> . IDENTIFIER OPERATOR SEMICOLON
    (23) assignment -> . IDENTIFIER EQUAL exp SEMICOLON
    (24) assignment -> . type IDENTIFIER EQUAL exp SEMICOLON
    (25) assignment -> . type IDENTIFIER SEMICOLON
    (26) if -> . IF LPAREN exp_if RPAREN LBRACE statements RBRACE else_elseif
    (32) for -> . FOR LPAREN exp_for RPAREN LBRACE statements RBRACE
    (51) array -> . type IDENTIFIER LBRACK NUMBER RBRACK SEMICOLON
    (52) array -> . type IDENTIFIER LBRACK NUMBER RBRACK EQUAL LBRACE elements_array RBRACE SEMICOLON
    (53) array -> . type IDENTIFIER LBRACK RBRACK EQUAL LBRACE elements_array RBRACE SEMICOLON
    (54) array -> . IDENTIFIER LBRACK NUMBER RBRACK EQUAL exp SEMICOLON
    (55) array -> . IDENTIFIER LBRACK IDENTIFIER RBRACK EQUAL exp SEMICOLON
    (12) func -> . type IDENTIFIER LPAREN args RPAREN LBRACE RBRACE
    (16) func -> . type IDENTIFIER LPAREN args RPAREN LBRACE statements RBRACE
    (17) func -> . IDENTIFIER LPAREN rec RPAREN SEMICOLON
    (21) func -> . type IDENTIFIER LPAREN RPAREN LBRACE statements RBRACE
    (62) print -> . PRINTF LPAREN STRING COMMA arguments RPAREN SEMICOLON
    (68) type -> . INT
    (69) type -> . DOUBLE
    (70) type -> . CHARS
    (71) type -> . STRINGS
    (72) type -> . BOOL
    (73) type -> . VOID

  ! reduce/reduce conflict for RBRACE resolved using rule 4 (statements -> .)
  ! shift/reduce conflict for IDENTIFIER resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for PRINTF resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for DOUBLE resolved as shift
  ! shift/reduce conflict for CHARS resolved as shift
  ! shift/reduce conflict for STRINGS resolved as shift
  ! shift/reduce conflict for BOOL resolved as shift
  ! shift/reduce conflict for VOID resolved as shift
    RBRACE          reduce using rule 4 (statements -> .)
    IDENTIFIER      shift and go to state 9
    IF              shift and go to state 11
    FOR             shift and go to state 12
    PRINTF          shift and go to state 13
    INT             shift and go to state 14
    DOUBLE          shift and go to state 15
    CHARS           shift and go to state 16
    STRINGS         shift and go to state 17
    BOOL            shift and go to state 18
    VOID            shift and go to state 19

  ! IDENTIFIER      [ reduce using rule 11 (statement -> .) ]
  ! IF              [ reduce using rule 11 (statement -> .) ]
  ! FOR             [ reduce using rule 11 (statement -> .) ]
  ! PRINTF          [ reduce using rule 11 (statement -> .) ]
  ! INT             [ reduce using rule 11 (statement -> .) ]
  ! DOUBLE          [ reduce using rule 11 (statement -> .) ]
  ! CHARS           [ reduce using rule 11 (statement -> .) ]
  ! STRINGS         [ reduce using rule 11 (statement -> .) ]
  ! BOOL            [ reduce using rule 11 (statement -> .) ]
  ! VOID            [ reduce using rule 11 (statement -> .) ]
  ! RBRACE          [ reduce using rule 11 (statement -> .) ]

    statements                     shift and go to state 105
    statement                      shift and go to state 103
    assignment                     shift and go to state 3
    if                             shift and go to state 4
    for                            shift and go to state 5
    array                          shift and go to state 6
    func                           shift and go to state 7
    print                          shift and go to state 8
    type                           shift and go to state 10

state 88

    (37) exp_for -> init exp_if SEMICOLON . increment
    (40) increment -> . IDENTIFIER OPERATOR
    (41) increment -> . IDENTIFIER EQUAL exp

    IDENTIFIER      shift and go to state 107

    increment                      shift and go to state 106

state 89

    (38) init -> IDENTIFIER EQUAL exp . SEMICOLON
    (49) exp -> exp . OPERATOR exp
    (50) exp -> exp . OPERATOR

    SEMICOLON       shift and go to state 108
    OPERATOR        shift and go to state 54


state 90

    (62) print -> PRINTF LPAREN STRING COMMA arguments . RPAREN SEMICOLON

    RPAREN          shift and go to state 109


state 91

    (63) arguments -> exp .
    (64) arguments -> exp . COMMA arguments
    (49) exp -> exp . OPERATOR exp
    (50) exp -> exp . OPERATOR

    RPAREN          reduce using rule 63 (arguments -> exp .)
    COMMA           shift and go to state 110
    OPERATOR        shift and go to state 54


state 92

    (65) arguments -> IDENTIFIER .
    (66) arguments -> IDENTIFIER . COMMA arguments
    (42) exp -> IDENTIFIER .
    (47) exp -> IDENTIFIER . LBRACK NUMBER RBRACK
    (48) exp -> IDENTIFIER . LBRACK IDENTIFIER RBRACK

  ! shift/reduce conflict for COMMA resolved as shift
  ! reduce/reduce conflict for RPAREN resolved using rule 42 (exp -> IDENTIFIER .)
    COMMA           shift and go to state 111
    OPERATOR        reduce using rule 42 (exp -> IDENTIFIER .)
    RPAREN          reduce using rule 42 (exp -> IDENTIFIER .)
    LBRACK          shift and go to state 52

  ! RPAREN          [ reduce using rule 65 (arguments -> IDENTIFIER .) ]
  ! COMMA           [ reduce using rule 42 (exp -> IDENTIFIER .) ]


state 93

    (48) exp -> IDENTIFIER LBRACK IDENTIFIER RBRACK .

    SEMICOLON       reduce using rule 48 (exp -> IDENTIFIER LBRACK IDENTIFIER RBRACK .)
    OPERATOR        reduce using rule 48 (exp -> IDENTIFIER LBRACK IDENTIFIER RBRACK .)
    COMMA           reduce using rule 48 (exp -> IDENTIFIER LBRACK IDENTIFIER RBRACK .)
    RPAREN          reduce using rule 48 (exp -> IDENTIFIER LBRACK IDENTIFIER RBRACK .)


state 94

    (47) exp -> IDENTIFIER LBRACK NUMBER RBRACK .

    SEMICOLON       reduce using rule 47 (exp -> IDENTIFIER LBRACK NUMBER RBRACK .)
    OPERATOR        reduce using rule 47 (exp -> IDENTIFIER LBRACK NUMBER RBRACK .)
    COMMA           reduce using rule 47 (exp -> IDENTIFIER LBRACK NUMBER RBRACK .)
    RPAREN          reduce using rule 47 (exp -> IDENTIFIER LBRACK NUMBER RBRACK .)


state 95

    (55) array -> IDENTIFIER LBRACK IDENTIFIER RBRACK EQUAL exp . SEMICOLON
    (49) exp -> exp . OPERATOR exp
    (50) exp -> exp . OPERATOR

    SEMICOLON       shift and go to state 112
    OPERATOR        shift and go to state 54


state 96

    (54) array -> IDENTIFIER LBRACK NUMBER RBRACK EQUAL exp . SEMICOLON
    (49) exp -> exp . OPERATOR exp
    (50) exp -> exp . OPERATOR

    SEMICOLON       shift and go to state 113
    OPERATOR        shift and go to state 54


state 97

    (51) array -> type IDENTIFIER LBRACK NUMBER RBRACK SEMICOLON .

    IDENTIFIER      reduce using rule 51 (array -> type IDENTIFIER LBRACK NUMBER RBRACK SEMICOLON .)
    IF              reduce using rule 51 (array -> type IDENTIFIER LBRACK NUMBER RBRACK SEMICOLON .)
    FOR             reduce using rule 51 (array -> type IDENTIFIER LBRACK NUMBER RBRACK SEMICOLON .)
    PRINTF          reduce using rule 51 (array -> type IDENTIFIER LBRACK NUMBER RBRACK SEMICOLON .)
    INT             reduce using rule 51 (array -> type IDENTIFIER LBRACK NUMBER RBRACK SEMICOLON .)
    DOUBLE          reduce using rule 51 (array -> type IDENTIFIER LBRACK NUMBER RBRACK SEMICOLON .)
    CHARS           reduce using rule 51 (array -> type IDENTIFIER LBRACK NUMBER RBRACK SEMICOLON .)
    STRINGS         reduce using rule 51 (array -> type IDENTIFIER LBRACK NUMBER RBRACK SEMICOLON .)
    BOOL            reduce using rule 51 (array -> type IDENTIFIER LBRACK NUMBER RBRACK SEMICOLON .)
    VOID            reduce using rule 51 (array -> type IDENTIFIER LBRACK NUMBER RBRACK SEMICOLON .)
    $end            reduce using rule 51 (array -> type IDENTIFIER LBRACK NUMBER RBRACK SEMICOLON .)
    RBRACE          reduce using rule 51 (array -> type IDENTIFIER LBRACK NUMBER RBRACK SEMICOLON .)


state 98

    (52) array -> type IDENTIFIER LBRACK NUMBER RBRACK EQUAL . LBRACE elements_array RBRACE SEMICOLON

    LBRACE          shift and go to state 114


state 99

    (53) array -> type IDENTIFIER LBRACK RBRACK EQUAL LBRACE . elements_array RBRACE SEMICOLON
    (56) elements_array -> . NUMBER
    (57) elements_array -> . CHAR
    (58) elements_array -> . TRUE
    (59) elements_array -> . FALSE
    (60) elements_array -> . elements_array COMMA elements_array
    (61) elements_array -> .

    NUMBER          shift and go to state 116
    CHAR            shift and go to state 117
    TRUE            shift and go to state 118
    FALSE           shift and go to state 119
    RBRACE          reduce using rule 61 (elements_array -> .)
    COMMA           reduce using rule 61 (elements_array -> .)

    elements_array                 shift and go to state 115

state 100

    (13) args -> type IDENTIFIER COMMA . args
    (13) args -> . type IDENTIFIER COMMA args
    (14) args -> . type IDENTIFIER
    (15) args -> .
    (68) type -> . INT
    (69) type -> . DOUBLE
    (70) type -> . CHARS
    (71) type -> . STRINGS
    (72) type -> . BOOL
    (73) type -> . VOID

    RPAREN          reduce using rule 15 (args -> .)
    INT             shift and go to state 14
    DOUBLE          shift and go to state 15
    CHARS           shift and go to state 16
    STRINGS         shift and go to state 17
    BOOL            shift and go to state 18
    VOID            shift and go to state 19

    type                           shift and go to state 62
    args                           shift and go to state 120

state 101

    (12) func -> type IDENTIFIER LPAREN args RPAREN LBRACE . RBRACE
    (16) func -> type IDENTIFIER LPAREN args RPAREN LBRACE . statements RBRACE
    (3) statements -> . statement statements
    (4) statements -> .
    (5) statement -> . assignment
    (6) statement -> . if
    (7) statement -> . for
    (8) statement -> . array
    (9) statement -> . func
    (10) statement -> . print
    (11) statement -> .
    (22) assignment -> . IDENTIFIER OPERATOR SEMICOLON
    (23) assignment -> . IDENTIFIER EQUAL exp SEMICOLON
    (24) assignment -> . type IDENTIFIER EQUAL exp SEMICOLON
    (25) assignment -> . type IDENTIFIER SEMICOLON
    (26) if -> . IF LPAREN exp_if RPAREN LBRACE statements RBRACE else_elseif
    (32) for -> . FOR LPAREN exp_for RPAREN LBRACE statements RBRACE
    (51) array -> . type IDENTIFIER LBRACK NUMBER RBRACK SEMICOLON
    (52) array -> . type IDENTIFIER LBRACK NUMBER RBRACK EQUAL LBRACE elements_array RBRACE SEMICOLON
    (53) array -> . type IDENTIFIER LBRACK RBRACK EQUAL LBRACE elements_array RBRACE SEMICOLON
    (54) array -> . IDENTIFIER LBRACK NUMBER RBRACK EQUAL exp SEMICOLON
    (55) array -> . IDENTIFIER LBRACK IDENTIFIER RBRACK EQUAL exp SEMICOLON
    (12) func -> . type IDENTIFIER LPAREN args RPAREN LBRACE RBRACE
    (16) func -> . type IDENTIFIER LPAREN args RPAREN LBRACE statements RBRACE
    (17) func -> . IDENTIFIER LPAREN rec RPAREN SEMICOLON
    (21) func -> . type IDENTIFIER LPAREN RPAREN LBRACE statements RBRACE
    (62) print -> . PRINTF LPAREN STRING COMMA arguments RPAREN SEMICOLON
    (68) type -> . INT
    (69) type -> . DOUBLE
    (70) type -> . CHARS
    (71) type -> . STRINGS
    (72) type -> . BOOL
    (73) type -> . VOID

  ! shift/reduce conflict for RBRACE resolved as shift
  ! shift/reduce conflict for RBRACE resolved as shift
  ! shift/reduce conflict for IDENTIFIER resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for PRINTF resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for DOUBLE resolved as shift
  ! shift/reduce conflict for CHARS resolved as shift
  ! shift/reduce conflict for STRINGS resolved as shift
  ! shift/reduce conflict for BOOL resolved as shift
  ! shift/reduce conflict for VOID resolved as shift
    RBRACE          shift and go to state 121
    IDENTIFIER      shift and go to state 9
    IF              shift and go to state 11
    FOR             shift and go to state 12
    PRINTF          shift and go to state 13
    INT             shift and go to state 14
    DOUBLE          shift and go to state 15
    CHARS           shift and go to state 16
    STRINGS         shift and go to state 17
    BOOL            shift and go to state 18
    VOID            shift and go to state 19

  ! RBRACE          [ reduce using rule 4 (statements -> .) ]
  ! IDENTIFIER      [ reduce using rule 11 (statement -> .) ]
  ! IF              [ reduce using rule 11 (statement -> .) ]
  ! FOR             [ reduce using rule 11 (statement -> .) ]
  ! PRINTF          [ reduce using rule 11 (statement -> .) ]
  ! INT             [ reduce using rule 11 (statement -> .) ]
  ! DOUBLE          [ reduce using rule 11 (statement -> .) ]
  ! CHARS           [ reduce using rule 11 (statement -> .) ]
  ! STRINGS         [ reduce using rule 11 (statement -> .) ]
  ! BOOL            [ reduce using rule 11 (statement -> .) ]
  ! VOID            [ reduce using rule 11 (statement -> .) ]
  ! RBRACE          [ reduce using rule 11 (statement -> .) ]

    type                           shift and go to state 10
    statements                     shift and go to state 122
    statement                      shift and go to state 103
    assignment                     shift and go to state 3
    if                             shift and go to state 4
    for                            shift and go to state 5
    array                          shift and go to state 6
    func                           shift and go to state 7
    print                          shift and go to state 8

state 102

    (21) func -> type IDENTIFIER LPAREN RPAREN LBRACE statements . RBRACE

    RBRACE          shift and go to state 123


state 103

    (3) statements -> statement . statements
    (3) statements -> . statement statements
    (4) statements -> .
    (5) statement -> . assignment
    (6) statement -> . if
    (7) statement -> . for
    (8) statement -> . array
    (9) statement -> . func
    (10) statement -> . print
    (11) statement -> .
    (22) assignment -> . IDENTIFIER OPERATOR SEMICOLON
    (23) assignment -> . IDENTIFIER EQUAL exp SEMICOLON
    (24) assignment -> . type IDENTIFIER EQUAL exp SEMICOLON
    (25) assignment -> . type IDENTIFIER SEMICOLON
    (26) if -> . IF LPAREN exp_if RPAREN LBRACE statements RBRACE else_elseif
    (32) for -> . FOR LPAREN exp_for RPAREN LBRACE statements RBRACE
    (51) array -> . type IDENTIFIER LBRACK NUMBER RBRACK SEMICOLON
    (52) array -> . type IDENTIFIER LBRACK NUMBER RBRACK EQUAL LBRACE elements_array RBRACE SEMICOLON
    (53) array -> . type IDENTIFIER LBRACK RBRACK EQUAL LBRACE elements_array RBRACE SEMICOLON
    (54) array -> . IDENTIFIER LBRACK NUMBER RBRACK EQUAL exp SEMICOLON
    (55) array -> . IDENTIFIER LBRACK IDENTIFIER RBRACK EQUAL exp SEMICOLON
    (12) func -> . type IDENTIFIER LPAREN args RPAREN LBRACE RBRACE
    (16) func -> . type IDENTIFIER LPAREN args RPAREN LBRACE statements RBRACE
    (17) func -> . IDENTIFIER LPAREN rec RPAREN SEMICOLON
    (21) func -> . type IDENTIFIER LPAREN RPAREN LBRACE statements RBRACE
    (62) print -> . PRINTF LPAREN STRING COMMA arguments RPAREN SEMICOLON
    (68) type -> . INT
    (69) type -> . DOUBLE
    (70) type -> . CHARS
    (71) type -> . STRINGS
    (72) type -> . BOOL
    (73) type -> . VOID

  ! reduce/reduce conflict for RBRACE resolved using rule 4 (statements -> .)
  ! shift/reduce conflict for IDENTIFIER resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for PRINTF resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for DOUBLE resolved as shift
  ! shift/reduce conflict for CHARS resolved as shift
  ! shift/reduce conflict for STRINGS resolved as shift
  ! shift/reduce conflict for BOOL resolved as shift
  ! shift/reduce conflict for VOID resolved as shift
    RBRACE          reduce using rule 4 (statements -> .)
    IDENTIFIER      shift and go to state 9
    IF              shift and go to state 11
    FOR             shift and go to state 12
    PRINTF          shift and go to state 13
    INT             shift and go to state 14
    DOUBLE          shift and go to state 15
    CHARS           shift and go to state 16
    STRINGS         shift and go to state 17
    BOOL            shift and go to state 18
    VOID            shift and go to state 19

  ! IDENTIFIER      [ reduce using rule 11 (statement -> .) ]
  ! IF              [ reduce using rule 11 (statement -> .) ]
  ! FOR             [ reduce using rule 11 (statement -> .) ]
  ! PRINTF          [ reduce using rule 11 (statement -> .) ]
  ! INT             [ reduce using rule 11 (statement -> .) ]
  ! DOUBLE          [ reduce using rule 11 (statement -> .) ]
  ! CHARS           [ reduce using rule 11 (statement -> .) ]
  ! STRINGS         [ reduce using rule 11 (statement -> .) ]
  ! BOOL            [ reduce using rule 11 (statement -> .) ]
  ! VOID            [ reduce using rule 11 (statement -> .) ]
  ! RBRACE          [ reduce using rule 11 (statement -> .) ]

    statement                      shift and go to state 103
    statements                     shift and go to state 124
    assignment                     shift and go to state 3
    if                             shift and go to state 4
    for                            shift and go to state 5
    array                          shift and go to state 6
    func                           shift and go to state 7
    print                          shift and go to state 8
    type                           shift and go to state 10

state 104

    (26) if -> IF LPAREN exp_if RPAREN LBRACE statements . RBRACE else_elseif

    RBRACE          shift and go to state 125


state 105

    (32) for -> FOR LPAREN exp_for RPAREN LBRACE statements . RBRACE

    RBRACE          shift and go to state 126


state 106

    (37) exp_for -> init exp_if SEMICOLON increment .

    RPAREN          reduce using rule 37 (exp_for -> init exp_if SEMICOLON increment .)


state 107

    (40) increment -> IDENTIFIER . OPERATOR
    (41) increment -> IDENTIFIER . EQUAL exp

    OPERATOR        shift and go to state 127
    EQUAL           shift and go to state 128


state 108

    (38) init -> IDENTIFIER EQUAL exp SEMICOLON .

    IDENTIFIER      reduce using rule 38 (init -> IDENTIFIER EQUAL exp SEMICOLON .)
    NUMBER          reduce using rule 38 (init -> IDENTIFIER EQUAL exp SEMICOLON .)
    CHAR            reduce using rule 38 (init -> IDENTIFIER EQUAL exp SEMICOLON .)


state 109

    (62) print -> PRINTF LPAREN STRING COMMA arguments RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 129


state 110

    (64) arguments -> exp COMMA . arguments
    (63) arguments -> . exp
    (64) arguments -> . exp COMMA arguments
    (65) arguments -> . IDENTIFIER
    (66) arguments -> . IDENTIFIER COMMA arguments
    (67) arguments -> .
    (42) exp -> . IDENTIFIER
    (43) exp -> . NUMBER
    (44) exp -> . CHAR
    (45) exp -> . TRUE
    (46) exp -> . FALSE
    (47) exp -> . IDENTIFIER LBRACK NUMBER RBRACK
    (48) exp -> . IDENTIFIER LBRACK IDENTIFIER RBRACK
    (49) exp -> . exp OPERATOR exp
    (50) exp -> . exp OPERATOR

    IDENTIFIER      shift and go to state 92
    RPAREN          reduce using rule 67 (arguments -> .)
    NUMBER          shift and go to state 32
    CHAR            shift and go to state 33
    TRUE            shift and go to state 34
    FALSE           shift and go to state 35

    exp                            shift and go to state 91
    arguments                      shift and go to state 130

state 111

    (66) arguments -> IDENTIFIER COMMA . arguments
    (63) arguments -> . exp
    (64) arguments -> . exp COMMA arguments
    (65) arguments -> . IDENTIFIER
    (66) arguments -> . IDENTIFIER COMMA arguments
    (67) arguments -> .
    (42) exp -> . IDENTIFIER
    (43) exp -> . NUMBER
    (44) exp -> . CHAR
    (45) exp -> . TRUE
    (46) exp -> . FALSE
    (47) exp -> . IDENTIFIER LBRACK NUMBER RBRACK
    (48) exp -> . IDENTIFIER LBRACK IDENTIFIER RBRACK
    (49) exp -> . exp OPERATOR exp
    (50) exp -> . exp OPERATOR

    IDENTIFIER      shift and go to state 92
    RPAREN          reduce using rule 67 (arguments -> .)
    NUMBER          shift and go to state 32
    CHAR            shift and go to state 33
    TRUE            shift and go to state 34
    FALSE           shift and go to state 35

    arguments                      shift and go to state 131
    exp                            shift and go to state 91

state 112

    (55) array -> IDENTIFIER LBRACK IDENTIFIER RBRACK EQUAL exp SEMICOLON .

    IDENTIFIER      reduce using rule 55 (array -> IDENTIFIER LBRACK IDENTIFIER RBRACK EQUAL exp SEMICOLON .)
    IF              reduce using rule 55 (array -> IDENTIFIER LBRACK IDENTIFIER RBRACK EQUAL exp SEMICOLON .)
    FOR             reduce using rule 55 (array -> IDENTIFIER LBRACK IDENTIFIER RBRACK EQUAL exp SEMICOLON .)
    PRINTF          reduce using rule 55 (array -> IDENTIFIER LBRACK IDENTIFIER RBRACK EQUAL exp SEMICOLON .)
    INT             reduce using rule 55 (array -> IDENTIFIER LBRACK IDENTIFIER RBRACK EQUAL exp SEMICOLON .)
    DOUBLE          reduce using rule 55 (array -> IDENTIFIER LBRACK IDENTIFIER RBRACK EQUAL exp SEMICOLON .)
    CHARS           reduce using rule 55 (array -> IDENTIFIER LBRACK IDENTIFIER RBRACK EQUAL exp SEMICOLON .)
    STRINGS         reduce using rule 55 (array -> IDENTIFIER LBRACK IDENTIFIER RBRACK EQUAL exp SEMICOLON .)
    BOOL            reduce using rule 55 (array -> IDENTIFIER LBRACK IDENTIFIER RBRACK EQUAL exp SEMICOLON .)
    VOID            reduce using rule 55 (array -> IDENTIFIER LBRACK IDENTIFIER RBRACK EQUAL exp SEMICOLON .)
    $end            reduce using rule 55 (array -> IDENTIFIER LBRACK IDENTIFIER RBRACK EQUAL exp SEMICOLON .)
    RBRACE          reduce using rule 55 (array -> IDENTIFIER LBRACK IDENTIFIER RBRACK EQUAL exp SEMICOLON .)


state 113

    (54) array -> IDENTIFIER LBRACK NUMBER RBRACK EQUAL exp SEMICOLON .

    IDENTIFIER      reduce using rule 54 (array -> IDENTIFIER LBRACK NUMBER RBRACK EQUAL exp SEMICOLON .)
    IF              reduce using rule 54 (array -> IDENTIFIER LBRACK NUMBER RBRACK EQUAL exp SEMICOLON .)
    FOR             reduce using rule 54 (array -> IDENTIFIER LBRACK NUMBER RBRACK EQUAL exp SEMICOLON .)
    PRINTF          reduce using rule 54 (array -> IDENTIFIER LBRACK NUMBER RBRACK EQUAL exp SEMICOLON .)
    INT             reduce using rule 54 (array -> IDENTIFIER LBRACK NUMBER RBRACK EQUAL exp SEMICOLON .)
    DOUBLE          reduce using rule 54 (array -> IDENTIFIER LBRACK NUMBER RBRACK EQUAL exp SEMICOLON .)
    CHARS           reduce using rule 54 (array -> IDENTIFIER LBRACK NUMBER RBRACK EQUAL exp SEMICOLON .)
    STRINGS         reduce using rule 54 (array -> IDENTIFIER LBRACK NUMBER RBRACK EQUAL exp SEMICOLON .)
    BOOL            reduce using rule 54 (array -> IDENTIFIER LBRACK NUMBER RBRACK EQUAL exp SEMICOLON .)
    VOID            reduce using rule 54 (array -> IDENTIFIER LBRACK NUMBER RBRACK EQUAL exp SEMICOLON .)
    $end            reduce using rule 54 (array -> IDENTIFIER LBRACK NUMBER RBRACK EQUAL exp SEMICOLON .)
    RBRACE          reduce using rule 54 (array -> IDENTIFIER LBRACK NUMBER RBRACK EQUAL exp SEMICOLON .)


state 114

    (52) array -> type IDENTIFIER LBRACK NUMBER RBRACK EQUAL LBRACE . elements_array RBRACE SEMICOLON
    (56) elements_array -> . NUMBER
    (57) elements_array -> . CHAR
    (58) elements_array -> . TRUE
    (59) elements_array -> . FALSE
    (60) elements_array -> . elements_array COMMA elements_array
    (61) elements_array -> .

    NUMBER          shift and go to state 116
    CHAR            shift and go to state 117
    TRUE            shift and go to state 118
    FALSE           shift and go to state 119
    RBRACE          reduce using rule 61 (elements_array -> .)
    COMMA           reduce using rule 61 (elements_array -> .)

    elements_array                 shift and go to state 132

state 115

    (53) array -> type IDENTIFIER LBRACK RBRACK EQUAL LBRACE elements_array . RBRACE SEMICOLON
    (60) elements_array -> elements_array . COMMA elements_array

    RBRACE          shift and go to state 133
    COMMA           shift and go to state 134


state 116

    (56) elements_array -> NUMBER .

    RBRACE          reduce using rule 56 (elements_array -> NUMBER .)
    COMMA           reduce using rule 56 (elements_array -> NUMBER .)


state 117

    (57) elements_array -> CHAR .

    RBRACE          reduce using rule 57 (elements_array -> CHAR .)
    COMMA           reduce using rule 57 (elements_array -> CHAR .)


state 118

    (58) elements_array -> TRUE .

    RBRACE          reduce using rule 58 (elements_array -> TRUE .)
    COMMA           reduce using rule 58 (elements_array -> TRUE .)


state 119

    (59) elements_array -> FALSE .

    RBRACE          reduce using rule 59 (elements_array -> FALSE .)
    COMMA           reduce using rule 59 (elements_array -> FALSE .)


state 120

    (13) args -> type IDENTIFIER COMMA args .

    RPAREN          reduce using rule 13 (args -> type IDENTIFIER COMMA args .)


state 121

    (12) func -> type IDENTIFIER LPAREN args RPAREN LBRACE RBRACE .

    IDENTIFIER      reduce using rule 12 (func -> type IDENTIFIER LPAREN args RPAREN LBRACE RBRACE .)
    IF              reduce using rule 12 (func -> type IDENTIFIER LPAREN args RPAREN LBRACE RBRACE .)
    FOR             reduce using rule 12 (func -> type IDENTIFIER LPAREN args RPAREN LBRACE RBRACE .)
    PRINTF          reduce using rule 12 (func -> type IDENTIFIER LPAREN args RPAREN LBRACE RBRACE .)
    INT             reduce using rule 12 (func -> type IDENTIFIER LPAREN args RPAREN LBRACE RBRACE .)
    DOUBLE          reduce using rule 12 (func -> type IDENTIFIER LPAREN args RPAREN LBRACE RBRACE .)
    CHARS           reduce using rule 12 (func -> type IDENTIFIER LPAREN args RPAREN LBRACE RBRACE .)
    STRINGS         reduce using rule 12 (func -> type IDENTIFIER LPAREN args RPAREN LBRACE RBRACE .)
    BOOL            reduce using rule 12 (func -> type IDENTIFIER LPAREN args RPAREN LBRACE RBRACE .)
    VOID            reduce using rule 12 (func -> type IDENTIFIER LPAREN args RPAREN LBRACE RBRACE .)
    $end            reduce using rule 12 (func -> type IDENTIFIER LPAREN args RPAREN LBRACE RBRACE .)
    RBRACE          reduce using rule 12 (func -> type IDENTIFIER LPAREN args RPAREN LBRACE RBRACE .)


state 122

    (16) func -> type IDENTIFIER LPAREN args RPAREN LBRACE statements . RBRACE

    RBRACE          shift and go to state 135


state 123

    (21) func -> type IDENTIFIER LPAREN RPAREN LBRACE statements RBRACE .

    IDENTIFIER      reduce using rule 21 (func -> type IDENTIFIER LPAREN RPAREN LBRACE statements RBRACE .)
    IF              reduce using rule 21 (func -> type IDENTIFIER LPAREN RPAREN LBRACE statements RBRACE .)
    FOR             reduce using rule 21 (func -> type IDENTIFIER LPAREN RPAREN LBRACE statements RBRACE .)
    PRINTF          reduce using rule 21 (func -> type IDENTIFIER LPAREN RPAREN LBRACE statements RBRACE .)
    INT             reduce using rule 21 (func -> type IDENTIFIER LPAREN RPAREN LBRACE statements RBRACE .)
    DOUBLE          reduce using rule 21 (func -> type IDENTIFIER LPAREN RPAREN LBRACE statements RBRACE .)
    CHARS           reduce using rule 21 (func -> type IDENTIFIER LPAREN RPAREN LBRACE statements RBRACE .)
    STRINGS         reduce using rule 21 (func -> type IDENTIFIER LPAREN RPAREN LBRACE statements RBRACE .)
    BOOL            reduce using rule 21 (func -> type IDENTIFIER LPAREN RPAREN LBRACE statements RBRACE .)
    VOID            reduce using rule 21 (func -> type IDENTIFIER LPAREN RPAREN LBRACE statements RBRACE .)
    $end            reduce using rule 21 (func -> type IDENTIFIER LPAREN RPAREN LBRACE statements RBRACE .)
    RBRACE          reduce using rule 21 (func -> type IDENTIFIER LPAREN RPAREN LBRACE statements RBRACE .)


state 124

    (3) statements -> statement statements .

    RBRACE          reduce using rule 3 (statements -> statement statements .)


state 125

    (26) if -> IF LPAREN exp_if RPAREN LBRACE statements RBRACE . else_elseif
    (27) else_elseif -> . elseif else_elseif
    (28) else_elseif -> . else else_elseif
    (29) else_elseif -> .
    (30) elseif -> . ELSE IF LPAREN exp_if RPAREN LBRACE statements RBRACE
    (31) else -> . ELSE LBRACE statements RBRACE

    IDENTIFIER      reduce using rule 29 (else_elseif -> .)
    IF              reduce using rule 29 (else_elseif -> .)
    FOR             reduce using rule 29 (else_elseif -> .)
    PRINTF          reduce using rule 29 (else_elseif -> .)
    INT             reduce using rule 29 (else_elseif -> .)
    DOUBLE          reduce using rule 29 (else_elseif -> .)
    CHARS           reduce using rule 29 (else_elseif -> .)
    STRINGS         reduce using rule 29 (else_elseif -> .)
    BOOL            reduce using rule 29 (else_elseif -> .)
    VOID            reduce using rule 29 (else_elseif -> .)
    $end            reduce using rule 29 (else_elseif -> .)
    RBRACE          reduce using rule 29 (else_elseif -> .)
    ELSE            shift and go to state 139

    else_elseif                    shift and go to state 136
    elseif                         shift and go to state 137
    else                           shift and go to state 138

state 126

    (32) for -> FOR LPAREN exp_for RPAREN LBRACE statements RBRACE .

    IDENTIFIER      reduce using rule 32 (for -> FOR LPAREN exp_for RPAREN LBRACE statements RBRACE .)
    IF              reduce using rule 32 (for -> FOR LPAREN exp_for RPAREN LBRACE statements RBRACE .)
    FOR             reduce using rule 32 (for -> FOR LPAREN exp_for RPAREN LBRACE statements RBRACE .)
    PRINTF          reduce using rule 32 (for -> FOR LPAREN exp_for RPAREN LBRACE statements RBRACE .)
    INT             reduce using rule 32 (for -> FOR LPAREN exp_for RPAREN LBRACE statements RBRACE .)
    DOUBLE          reduce using rule 32 (for -> FOR LPAREN exp_for RPAREN LBRACE statements RBRACE .)
    CHARS           reduce using rule 32 (for -> FOR LPAREN exp_for RPAREN LBRACE statements RBRACE .)
    STRINGS         reduce using rule 32 (for -> FOR LPAREN exp_for RPAREN LBRACE statements RBRACE .)
    BOOL            reduce using rule 32 (for -> FOR LPAREN exp_for RPAREN LBRACE statements RBRACE .)
    VOID            reduce using rule 32 (for -> FOR LPAREN exp_for RPAREN LBRACE statements RBRACE .)
    $end            reduce using rule 32 (for -> FOR LPAREN exp_for RPAREN LBRACE statements RBRACE .)
    RBRACE          reduce using rule 32 (for -> FOR LPAREN exp_for RPAREN LBRACE statements RBRACE .)


state 127

    (40) increment -> IDENTIFIER OPERATOR .

    RPAREN          reduce using rule 40 (increment -> IDENTIFIER OPERATOR .)


state 128

    (41) increment -> IDENTIFIER EQUAL . exp
    (42) exp -> . IDENTIFIER
    (43) exp -> . NUMBER
    (44) exp -> . CHAR
    (45) exp -> . TRUE
    (46) exp -> . FALSE
    (47) exp -> . IDENTIFIER LBRACK NUMBER RBRACK
    (48) exp -> . IDENTIFIER LBRACK IDENTIFIER RBRACK
    (49) exp -> . exp OPERATOR exp
    (50) exp -> . exp OPERATOR

    IDENTIFIER      shift and go to state 30
    NUMBER          shift and go to state 32
    CHAR            shift and go to state 33
    TRUE            shift and go to state 34
    FALSE           shift and go to state 35

    exp                            shift and go to state 140

state 129

    (62) print -> PRINTF LPAREN STRING COMMA arguments RPAREN SEMICOLON .

    IDENTIFIER      reduce using rule 62 (print -> PRINTF LPAREN STRING COMMA arguments RPAREN SEMICOLON .)
    IF              reduce using rule 62 (print -> PRINTF LPAREN STRING COMMA arguments RPAREN SEMICOLON .)
    FOR             reduce using rule 62 (print -> PRINTF LPAREN STRING COMMA arguments RPAREN SEMICOLON .)
    PRINTF          reduce using rule 62 (print -> PRINTF LPAREN STRING COMMA arguments RPAREN SEMICOLON .)
    INT             reduce using rule 62 (print -> PRINTF LPAREN STRING COMMA arguments RPAREN SEMICOLON .)
    DOUBLE          reduce using rule 62 (print -> PRINTF LPAREN STRING COMMA arguments RPAREN SEMICOLON .)
    CHARS           reduce using rule 62 (print -> PRINTF LPAREN STRING COMMA arguments RPAREN SEMICOLON .)
    STRINGS         reduce using rule 62 (print -> PRINTF LPAREN STRING COMMA arguments RPAREN SEMICOLON .)
    BOOL            reduce using rule 62 (print -> PRINTF LPAREN STRING COMMA arguments RPAREN SEMICOLON .)
    VOID            reduce using rule 62 (print -> PRINTF LPAREN STRING COMMA arguments RPAREN SEMICOLON .)
    $end            reduce using rule 62 (print -> PRINTF LPAREN STRING COMMA arguments RPAREN SEMICOLON .)
    RBRACE          reduce using rule 62 (print -> PRINTF LPAREN STRING COMMA arguments RPAREN SEMICOLON .)


state 130

    (64) arguments -> exp COMMA arguments .

    RPAREN          reduce using rule 64 (arguments -> exp COMMA arguments .)


state 131

    (66) arguments -> IDENTIFIER COMMA arguments .

    RPAREN          reduce using rule 66 (arguments -> IDENTIFIER COMMA arguments .)


state 132

    (52) array -> type IDENTIFIER LBRACK NUMBER RBRACK EQUAL LBRACE elements_array . RBRACE SEMICOLON
    (60) elements_array -> elements_array . COMMA elements_array

    RBRACE          shift and go to state 141
    COMMA           shift and go to state 134


state 133

    (53) array -> type IDENTIFIER LBRACK RBRACK EQUAL LBRACE elements_array RBRACE . SEMICOLON

    SEMICOLON       shift and go to state 142


state 134

    (60) elements_array -> elements_array COMMA . elements_array
    (56) elements_array -> . NUMBER
    (57) elements_array -> . CHAR
    (58) elements_array -> . TRUE
    (59) elements_array -> . FALSE
    (60) elements_array -> . elements_array COMMA elements_array
    (61) elements_array -> .

    NUMBER          shift and go to state 116
    CHAR            shift and go to state 117
    TRUE            shift and go to state 118
    FALSE           shift and go to state 119
    COMMA           reduce using rule 61 (elements_array -> .)
    RBRACE          reduce using rule 61 (elements_array -> .)

    elements_array                 shift and go to state 143

state 135

    (16) func -> type IDENTIFIER LPAREN args RPAREN LBRACE statements RBRACE .

    IDENTIFIER      reduce using rule 16 (func -> type IDENTIFIER LPAREN args RPAREN LBRACE statements RBRACE .)
    IF              reduce using rule 16 (func -> type IDENTIFIER LPAREN args RPAREN LBRACE statements RBRACE .)
    FOR             reduce using rule 16 (func -> type IDENTIFIER LPAREN args RPAREN LBRACE statements RBRACE .)
    PRINTF          reduce using rule 16 (func -> type IDENTIFIER LPAREN args RPAREN LBRACE statements RBRACE .)
    INT             reduce using rule 16 (func -> type IDENTIFIER LPAREN args RPAREN LBRACE statements RBRACE .)
    DOUBLE          reduce using rule 16 (func -> type IDENTIFIER LPAREN args RPAREN LBRACE statements RBRACE .)
    CHARS           reduce using rule 16 (func -> type IDENTIFIER LPAREN args RPAREN LBRACE statements RBRACE .)
    STRINGS         reduce using rule 16 (func -> type IDENTIFIER LPAREN args RPAREN LBRACE statements RBRACE .)
    BOOL            reduce using rule 16 (func -> type IDENTIFIER LPAREN args RPAREN LBRACE statements RBRACE .)
    VOID            reduce using rule 16 (func -> type IDENTIFIER LPAREN args RPAREN LBRACE statements RBRACE .)
    $end            reduce using rule 16 (func -> type IDENTIFIER LPAREN args RPAREN LBRACE statements RBRACE .)
    RBRACE          reduce using rule 16 (func -> type IDENTIFIER LPAREN args RPAREN LBRACE statements RBRACE .)


state 136

    (26) if -> IF LPAREN exp_if RPAREN LBRACE statements RBRACE else_elseif .

    IDENTIFIER      reduce using rule 26 (if -> IF LPAREN exp_if RPAREN LBRACE statements RBRACE else_elseif .)
    IF              reduce using rule 26 (if -> IF LPAREN exp_if RPAREN LBRACE statements RBRACE else_elseif .)
    FOR             reduce using rule 26 (if -> IF LPAREN exp_if RPAREN LBRACE statements RBRACE else_elseif .)
    PRINTF          reduce using rule 26 (if -> IF LPAREN exp_if RPAREN LBRACE statements RBRACE else_elseif .)
    INT             reduce using rule 26 (if -> IF LPAREN exp_if RPAREN LBRACE statements RBRACE else_elseif .)
    DOUBLE          reduce using rule 26 (if -> IF LPAREN exp_if RPAREN LBRACE statements RBRACE else_elseif .)
    CHARS           reduce using rule 26 (if -> IF LPAREN exp_if RPAREN LBRACE statements RBRACE else_elseif .)
    STRINGS         reduce using rule 26 (if -> IF LPAREN exp_if RPAREN LBRACE statements RBRACE else_elseif .)
    BOOL            reduce using rule 26 (if -> IF LPAREN exp_if RPAREN LBRACE statements RBRACE else_elseif .)
    VOID            reduce using rule 26 (if -> IF LPAREN exp_if RPAREN LBRACE statements RBRACE else_elseif .)
    $end            reduce using rule 26 (if -> IF LPAREN exp_if RPAREN LBRACE statements RBRACE else_elseif .)
    RBRACE          reduce using rule 26 (if -> IF LPAREN exp_if RPAREN LBRACE statements RBRACE else_elseif .)


state 137

    (27) else_elseif -> elseif . else_elseif
    (27) else_elseif -> . elseif else_elseif
    (28) else_elseif -> . else else_elseif
    (29) else_elseif -> .
    (30) elseif -> . ELSE IF LPAREN exp_if RPAREN LBRACE statements RBRACE
    (31) else -> . ELSE LBRACE statements RBRACE

    IDENTIFIER      reduce using rule 29 (else_elseif -> .)
    IF              reduce using rule 29 (else_elseif -> .)
    FOR             reduce using rule 29 (else_elseif -> .)
    PRINTF          reduce using rule 29 (else_elseif -> .)
    INT             reduce using rule 29 (else_elseif -> .)
    DOUBLE          reduce using rule 29 (else_elseif -> .)
    CHARS           reduce using rule 29 (else_elseif -> .)
    STRINGS         reduce using rule 29 (else_elseif -> .)
    BOOL            reduce using rule 29 (else_elseif -> .)
    VOID            reduce using rule 29 (else_elseif -> .)
    $end            reduce using rule 29 (else_elseif -> .)
    RBRACE          reduce using rule 29 (else_elseif -> .)
    ELSE            shift and go to state 139

    elseif                         shift and go to state 137
    else_elseif                    shift and go to state 144
    else                           shift and go to state 138

state 138

    (28) else_elseif -> else . else_elseif
    (27) else_elseif -> . elseif else_elseif
    (28) else_elseif -> . else else_elseif
    (29) else_elseif -> .
    (30) elseif -> . ELSE IF LPAREN exp_if RPAREN LBRACE statements RBRACE
    (31) else -> . ELSE LBRACE statements RBRACE

    IDENTIFIER      reduce using rule 29 (else_elseif -> .)
    IF              reduce using rule 29 (else_elseif -> .)
    FOR             reduce using rule 29 (else_elseif -> .)
    PRINTF          reduce using rule 29 (else_elseif -> .)
    INT             reduce using rule 29 (else_elseif -> .)
    DOUBLE          reduce using rule 29 (else_elseif -> .)
    CHARS           reduce using rule 29 (else_elseif -> .)
    STRINGS         reduce using rule 29 (else_elseif -> .)
    BOOL            reduce using rule 29 (else_elseif -> .)
    VOID            reduce using rule 29 (else_elseif -> .)
    $end            reduce using rule 29 (else_elseif -> .)
    RBRACE          reduce using rule 29 (else_elseif -> .)
    ELSE            shift and go to state 139

    else                           shift and go to state 138
    else_elseif                    shift and go to state 145
    elseif                         shift and go to state 137

state 139

    (30) elseif -> ELSE . IF LPAREN exp_if RPAREN LBRACE statements RBRACE
    (31) else -> ELSE . LBRACE statements RBRACE

    IF              shift and go to state 146
    LBRACE          shift and go to state 147


state 140

    (41) increment -> IDENTIFIER EQUAL exp .
    (49) exp -> exp . OPERATOR exp
    (50) exp -> exp . OPERATOR

    RPAREN          reduce using rule 41 (increment -> IDENTIFIER EQUAL exp .)
    OPERATOR        shift and go to state 54


state 141

    (52) array -> type IDENTIFIER LBRACK NUMBER RBRACK EQUAL LBRACE elements_array RBRACE . SEMICOLON

    SEMICOLON       shift and go to state 148


state 142

    (53) array -> type IDENTIFIER LBRACK RBRACK EQUAL LBRACE elements_array RBRACE SEMICOLON .

    IDENTIFIER      reduce using rule 53 (array -> type IDENTIFIER LBRACK RBRACK EQUAL LBRACE elements_array RBRACE SEMICOLON .)
    IF              reduce using rule 53 (array -> type IDENTIFIER LBRACK RBRACK EQUAL LBRACE elements_array RBRACE SEMICOLON .)
    FOR             reduce using rule 53 (array -> type IDENTIFIER LBRACK RBRACK EQUAL LBRACE elements_array RBRACE SEMICOLON .)
    PRINTF          reduce using rule 53 (array -> type IDENTIFIER LBRACK RBRACK EQUAL LBRACE elements_array RBRACE SEMICOLON .)
    INT             reduce using rule 53 (array -> type IDENTIFIER LBRACK RBRACK EQUAL LBRACE elements_array RBRACE SEMICOLON .)
    DOUBLE          reduce using rule 53 (array -> type IDENTIFIER LBRACK RBRACK EQUAL LBRACE elements_array RBRACE SEMICOLON .)
    CHARS           reduce using rule 53 (array -> type IDENTIFIER LBRACK RBRACK EQUAL LBRACE elements_array RBRACE SEMICOLON .)
    STRINGS         reduce using rule 53 (array -> type IDENTIFIER LBRACK RBRACK EQUAL LBRACE elements_array RBRACE SEMICOLON .)
    BOOL            reduce using rule 53 (array -> type IDENTIFIER LBRACK RBRACK EQUAL LBRACE elements_array RBRACE SEMICOLON .)
    VOID            reduce using rule 53 (array -> type IDENTIFIER LBRACK RBRACK EQUAL LBRACE elements_array RBRACE SEMICOLON .)
    $end            reduce using rule 53 (array -> type IDENTIFIER LBRACK RBRACK EQUAL LBRACE elements_array RBRACE SEMICOLON .)
    RBRACE          reduce using rule 53 (array -> type IDENTIFIER LBRACK RBRACK EQUAL LBRACE elements_array RBRACE SEMICOLON .)


state 143

    (60) elements_array -> elements_array COMMA elements_array .
    (60) elements_array -> elements_array . COMMA elements_array

  ! shift/reduce conflict for COMMA resolved as shift
    RBRACE          reduce using rule 60 (elements_array -> elements_array COMMA elements_array .)
    COMMA           shift and go to state 134

  ! COMMA           [ reduce using rule 60 (elements_array -> elements_array COMMA elements_array .) ]


state 144

    (27) else_elseif -> elseif else_elseif .

    IDENTIFIER      reduce using rule 27 (else_elseif -> elseif else_elseif .)
    IF              reduce using rule 27 (else_elseif -> elseif else_elseif .)
    FOR             reduce using rule 27 (else_elseif -> elseif else_elseif .)
    PRINTF          reduce using rule 27 (else_elseif -> elseif else_elseif .)
    INT             reduce using rule 27 (else_elseif -> elseif else_elseif .)
    DOUBLE          reduce using rule 27 (else_elseif -> elseif else_elseif .)
    CHARS           reduce using rule 27 (else_elseif -> elseif else_elseif .)
    STRINGS         reduce using rule 27 (else_elseif -> elseif else_elseif .)
    BOOL            reduce using rule 27 (else_elseif -> elseif else_elseif .)
    VOID            reduce using rule 27 (else_elseif -> elseif else_elseif .)
    $end            reduce using rule 27 (else_elseif -> elseif else_elseif .)
    RBRACE          reduce using rule 27 (else_elseif -> elseif else_elseif .)


state 145

    (28) else_elseif -> else else_elseif .

    IDENTIFIER      reduce using rule 28 (else_elseif -> else else_elseif .)
    IF              reduce using rule 28 (else_elseif -> else else_elseif .)
    FOR             reduce using rule 28 (else_elseif -> else else_elseif .)
    PRINTF          reduce using rule 28 (else_elseif -> else else_elseif .)
    INT             reduce using rule 28 (else_elseif -> else else_elseif .)
    DOUBLE          reduce using rule 28 (else_elseif -> else else_elseif .)
    CHARS           reduce using rule 28 (else_elseif -> else else_elseif .)
    STRINGS         reduce using rule 28 (else_elseif -> else else_elseif .)
    BOOL            reduce using rule 28 (else_elseif -> else else_elseif .)
    VOID            reduce using rule 28 (else_elseif -> else else_elseif .)
    $end            reduce using rule 28 (else_elseif -> else else_elseif .)
    RBRACE          reduce using rule 28 (else_elseif -> else else_elseif .)


state 146

    (30) elseif -> ELSE IF . LPAREN exp_if RPAREN LBRACE statements RBRACE

    LPAREN          shift and go to state 149


state 147

    (31) else -> ELSE LBRACE . statements RBRACE
    (3) statements -> . statement statements
    (4) statements -> .
    (5) statement -> . assignment
    (6) statement -> . if
    (7) statement -> . for
    (8) statement -> . array
    (9) statement -> . func
    (10) statement -> . print
    (11) statement -> .
    (22) assignment -> . IDENTIFIER OPERATOR SEMICOLON
    (23) assignment -> . IDENTIFIER EQUAL exp SEMICOLON
    (24) assignment -> . type IDENTIFIER EQUAL exp SEMICOLON
    (25) assignment -> . type IDENTIFIER SEMICOLON
    (26) if -> . IF LPAREN exp_if RPAREN LBRACE statements RBRACE else_elseif
    (32) for -> . FOR LPAREN exp_for RPAREN LBRACE statements RBRACE
    (51) array -> . type IDENTIFIER LBRACK NUMBER RBRACK SEMICOLON
    (52) array -> . type IDENTIFIER LBRACK NUMBER RBRACK EQUAL LBRACE elements_array RBRACE SEMICOLON
    (53) array -> . type IDENTIFIER LBRACK RBRACK EQUAL LBRACE elements_array RBRACE SEMICOLON
    (54) array -> . IDENTIFIER LBRACK NUMBER RBRACK EQUAL exp SEMICOLON
    (55) array -> . IDENTIFIER LBRACK IDENTIFIER RBRACK EQUAL exp SEMICOLON
    (12) func -> . type IDENTIFIER LPAREN args RPAREN LBRACE RBRACE
    (16) func -> . type IDENTIFIER LPAREN args RPAREN LBRACE statements RBRACE
    (17) func -> . IDENTIFIER LPAREN rec RPAREN SEMICOLON
    (21) func -> . type IDENTIFIER LPAREN RPAREN LBRACE statements RBRACE
    (62) print -> . PRINTF LPAREN STRING COMMA arguments RPAREN SEMICOLON
    (68) type -> . INT
    (69) type -> . DOUBLE
    (70) type -> . CHARS
    (71) type -> . STRINGS
    (72) type -> . BOOL
    (73) type -> . VOID

  ! reduce/reduce conflict for RBRACE resolved using rule 4 (statements -> .)
  ! shift/reduce conflict for IDENTIFIER resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for PRINTF resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for DOUBLE resolved as shift
  ! shift/reduce conflict for CHARS resolved as shift
  ! shift/reduce conflict for STRINGS resolved as shift
  ! shift/reduce conflict for BOOL resolved as shift
  ! shift/reduce conflict for VOID resolved as shift
    RBRACE          reduce using rule 4 (statements -> .)
    IDENTIFIER      shift and go to state 9
    IF              shift and go to state 11
    FOR             shift and go to state 12
    PRINTF          shift and go to state 13
    INT             shift and go to state 14
    DOUBLE          shift and go to state 15
    CHARS           shift and go to state 16
    STRINGS         shift and go to state 17
    BOOL            shift and go to state 18
    VOID            shift and go to state 19

  ! IDENTIFIER      [ reduce using rule 11 (statement -> .) ]
  ! IF              [ reduce using rule 11 (statement -> .) ]
  ! FOR             [ reduce using rule 11 (statement -> .) ]
  ! PRINTF          [ reduce using rule 11 (statement -> .) ]
  ! INT             [ reduce using rule 11 (statement -> .) ]
  ! DOUBLE          [ reduce using rule 11 (statement -> .) ]
  ! CHARS           [ reduce using rule 11 (statement -> .) ]
  ! STRINGS         [ reduce using rule 11 (statement -> .) ]
  ! BOOL            [ reduce using rule 11 (statement -> .) ]
  ! VOID            [ reduce using rule 11 (statement -> .) ]
  ! RBRACE          [ reduce using rule 11 (statement -> .) ]

    statements                     shift and go to state 150
    statement                      shift and go to state 103
    assignment                     shift and go to state 3
    if                             shift and go to state 4
    for                            shift and go to state 5
    array                          shift and go to state 6
    func                           shift and go to state 7
    print                          shift and go to state 8
    type                           shift and go to state 10

state 148

    (52) array -> type IDENTIFIER LBRACK NUMBER RBRACK EQUAL LBRACE elements_array RBRACE SEMICOLON .

    IDENTIFIER      reduce using rule 52 (array -> type IDENTIFIER LBRACK NUMBER RBRACK EQUAL LBRACE elements_array RBRACE SEMICOLON .)
    IF              reduce using rule 52 (array -> type IDENTIFIER LBRACK NUMBER RBRACK EQUAL LBRACE elements_array RBRACE SEMICOLON .)
    FOR             reduce using rule 52 (array -> type IDENTIFIER LBRACK NUMBER RBRACK EQUAL LBRACE elements_array RBRACE SEMICOLON .)
    PRINTF          reduce using rule 52 (array -> type IDENTIFIER LBRACK NUMBER RBRACK EQUAL LBRACE elements_array RBRACE SEMICOLON .)
    INT             reduce using rule 52 (array -> type IDENTIFIER LBRACK NUMBER RBRACK EQUAL LBRACE elements_array RBRACE SEMICOLON .)
    DOUBLE          reduce using rule 52 (array -> type IDENTIFIER LBRACK NUMBER RBRACK EQUAL LBRACE elements_array RBRACE SEMICOLON .)
    CHARS           reduce using rule 52 (array -> type IDENTIFIER LBRACK NUMBER RBRACK EQUAL LBRACE elements_array RBRACE SEMICOLON .)
    STRINGS         reduce using rule 52 (array -> type IDENTIFIER LBRACK NUMBER RBRACK EQUAL LBRACE elements_array RBRACE SEMICOLON .)
    BOOL            reduce using rule 52 (array -> type IDENTIFIER LBRACK NUMBER RBRACK EQUAL LBRACE elements_array RBRACE SEMICOLON .)
    VOID            reduce using rule 52 (array -> type IDENTIFIER LBRACK NUMBER RBRACK EQUAL LBRACE elements_array RBRACE SEMICOLON .)
    $end            reduce using rule 52 (array -> type IDENTIFIER LBRACK NUMBER RBRACK EQUAL LBRACE elements_array RBRACE SEMICOLON .)
    RBRACE          reduce using rule 52 (array -> type IDENTIFIER LBRACK NUMBER RBRACK EQUAL LBRACE elements_array RBRACE SEMICOLON .)


state 149

    (30) elseif -> ELSE IF LPAREN . exp_if RPAREN LBRACE statements RBRACE
    (33) exp_if -> . IDENTIFIER
    (34) exp_if -> . NUMBER
    (35) exp_if -> . CHAR
    (36) exp_if -> . exp_if RELATIONALOPERATOR exp_if

    IDENTIFIER      shift and go to state 45
    NUMBER          shift and go to state 46
    CHAR            shift and go to state 47

    exp_if                         shift and go to state 151

state 150

    (31) else -> ELSE LBRACE statements . RBRACE

    RBRACE          shift and go to state 152


state 151

    (30) elseif -> ELSE IF LPAREN exp_if . RPAREN LBRACE statements RBRACE
    (36) exp_if -> exp_if . RELATIONALOPERATOR exp_if

    RPAREN          shift and go to state 153
    RELATIONALOPERATOR shift and go to state 66


state 152

    (31) else -> ELSE LBRACE statements RBRACE .

    ELSE            reduce using rule 31 (else -> ELSE LBRACE statements RBRACE .)
    IDENTIFIER      reduce using rule 31 (else -> ELSE LBRACE statements RBRACE .)
    IF              reduce using rule 31 (else -> ELSE LBRACE statements RBRACE .)
    FOR             reduce using rule 31 (else -> ELSE LBRACE statements RBRACE .)
    PRINTF          reduce using rule 31 (else -> ELSE LBRACE statements RBRACE .)
    INT             reduce using rule 31 (else -> ELSE LBRACE statements RBRACE .)
    DOUBLE          reduce using rule 31 (else -> ELSE LBRACE statements RBRACE .)
    CHARS           reduce using rule 31 (else -> ELSE LBRACE statements RBRACE .)
    STRINGS         reduce using rule 31 (else -> ELSE LBRACE statements RBRACE .)
    BOOL            reduce using rule 31 (else -> ELSE LBRACE statements RBRACE .)
    VOID            reduce using rule 31 (else -> ELSE LBRACE statements RBRACE .)
    $end            reduce using rule 31 (else -> ELSE LBRACE statements RBRACE .)
    RBRACE          reduce using rule 31 (else -> ELSE LBRACE statements RBRACE .)


state 153

    (30) elseif -> ELSE IF LPAREN exp_if RPAREN . LBRACE statements RBRACE

    LBRACE          shift and go to state 154


state 154

    (30) elseif -> ELSE IF LPAREN exp_if RPAREN LBRACE . statements RBRACE
    (3) statements -> . statement statements
    (4) statements -> .
    (5) statement -> . assignment
    (6) statement -> . if
    (7) statement -> . for
    (8) statement -> . array
    (9) statement -> . func
    (10) statement -> . print
    (11) statement -> .
    (22) assignment -> . IDENTIFIER OPERATOR SEMICOLON
    (23) assignment -> . IDENTIFIER EQUAL exp SEMICOLON
    (24) assignment -> . type IDENTIFIER EQUAL exp SEMICOLON
    (25) assignment -> . type IDENTIFIER SEMICOLON
    (26) if -> . IF LPAREN exp_if RPAREN LBRACE statements RBRACE else_elseif
    (32) for -> . FOR LPAREN exp_for RPAREN LBRACE statements RBRACE
    (51) array -> . type IDENTIFIER LBRACK NUMBER RBRACK SEMICOLON
    (52) array -> . type IDENTIFIER LBRACK NUMBER RBRACK EQUAL LBRACE elements_array RBRACE SEMICOLON
    (53) array -> . type IDENTIFIER LBRACK RBRACK EQUAL LBRACE elements_array RBRACE SEMICOLON
    (54) array -> . IDENTIFIER LBRACK NUMBER RBRACK EQUAL exp SEMICOLON
    (55) array -> . IDENTIFIER LBRACK IDENTIFIER RBRACK EQUAL exp SEMICOLON
    (12) func -> . type IDENTIFIER LPAREN args RPAREN LBRACE RBRACE
    (16) func -> . type IDENTIFIER LPAREN args RPAREN LBRACE statements RBRACE
    (17) func -> . IDENTIFIER LPAREN rec RPAREN SEMICOLON
    (21) func -> . type IDENTIFIER LPAREN RPAREN LBRACE statements RBRACE
    (62) print -> . PRINTF LPAREN STRING COMMA arguments RPAREN SEMICOLON
    (68) type -> . INT
    (69) type -> . DOUBLE
    (70) type -> . CHARS
    (71) type -> . STRINGS
    (72) type -> . BOOL
    (73) type -> . VOID

  ! reduce/reduce conflict for RBRACE resolved using rule 4 (statements -> .)
  ! shift/reduce conflict for IDENTIFIER resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for PRINTF resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for DOUBLE resolved as shift
  ! shift/reduce conflict for CHARS resolved as shift
  ! shift/reduce conflict for STRINGS resolved as shift
  ! shift/reduce conflict for BOOL resolved as shift
  ! shift/reduce conflict for VOID resolved as shift
    RBRACE          reduce using rule 4 (statements -> .)
    IDENTIFIER      shift and go to state 9
    IF              shift and go to state 11
    FOR             shift and go to state 12
    PRINTF          shift and go to state 13
    INT             shift and go to state 14
    DOUBLE          shift and go to state 15
    CHARS           shift and go to state 16
    STRINGS         shift and go to state 17
    BOOL            shift and go to state 18
    VOID            shift and go to state 19

  ! IDENTIFIER      [ reduce using rule 11 (statement -> .) ]
  ! IF              [ reduce using rule 11 (statement -> .) ]
  ! FOR             [ reduce using rule 11 (statement -> .) ]
  ! PRINTF          [ reduce using rule 11 (statement -> .) ]
  ! INT             [ reduce using rule 11 (statement -> .) ]
  ! DOUBLE          [ reduce using rule 11 (statement -> .) ]
  ! CHARS           [ reduce using rule 11 (statement -> .) ]
  ! STRINGS         [ reduce using rule 11 (statement -> .) ]
  ! BOOL            [ reduce using rule 11 (statement -> .) ]
  ! VOID            [ reduce using rule 11 (statement -> .) ]
  ! RBRACE          [ reduce using rule 11 (statement -> .) ]

    statements                     shift and go to state 155
    statement                      shift and go to state 103
    assignment                     shift and go to state 3
    if                             shift and go to state 4
    for                            shift and go to state 5
    array                          shift and go to state 6
    func                           shift and go to state 7
    print                          shift and go to state 8
    type                           shift and go to state 10

state 155

    (30) elseif -> ELSE IF LPAREN exp_if RPAREN LBRACE statements . RBRACE

    RBRACE          shift and go to state 156


state 156

    (30) elseif -> ELSE IF LPAREN exp_if RPAREN LBRACE statements RBRACE .

    ELSE            reduce using rule 30 (elseif -> ELSE IF LPAREN exp_if RPAREN LBRACE statements RBRACE .)
    IDENTIFIER      reduce using rule 30 (elseif -> ELSE IF LPAREN exp_if RPAREN LBRACE statements RBRACE .)
    IF              reduce using rule 30 (elseif -> ELSE IF LPAREN exp_if RPAREN LBRACE statements RBRACE .)
    FOR             reduce using rule 30 (elseif -> ELSE IF LPAREN exp_if RPAREN LBRACE statements RBRACE .)
    PRINTF          reduce using rule 30 (elseif -> ELSE IF LPAREN exp_if RPAREN LBRACE statements RBRACE .)
    INT             reduce using rule 30 (elseif -> ELSE IF LPAREN exp_if RPAREN LBRACE statements RBRACE .)
    DOUBLE          reduce using rule 30 (elseif -> ELSE IF LPAREN exp_if RPAREN LBRACE statements RBRACE .)
    CHARS           reduce using rule 30 (elseif -> ELSE IF LPAREN exp_if RPAREN LBRACE statements RBRACE .)
    STRINGS         reduce using rule 30 (elseif -> ELSE IF LPAREN exp_if RPAREN LBRACE statements RBRACE .)
    BOOL            reduce using rule 30 (elseif -> ELSE IF LPAREN exp_if RPAREN LBRACE statements RBRACE .)
    VOID            reduce using rule 30 (elseif -> ELSE IF LPAREN exp_if RPAREN LBRACE statements RBRACE .)
    $end            reduce using rule 30 (elseif -> ELSE IF LPAREN exp_if RPAREN LBRACE statements RBRACE .)
    RBRACE          reduce using rule 30 (elseif -> ELSE IF LPAREN exp_if RPAREN LBRACE statements RBRACE .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for IDENTIFIER in state 0 resolved as shift
WARNING: shift/reduce conflict for IF in state 0 resolved as shift
WARNING: shift/reduce conflict for FOR in state 0 resolved as shift
WARNING: shift/reduce conflict for PRINTF in state 0 resolved as shift
WARNING: shift/reduce conflict for INT in state 0 resolved as shift
WARNING: shift/reduce conflict for DOUBLE in state 0 resolved as shift
WARNING: shift/reduce conflict for CHARS in state 0 resolved as shift
WARNING: shift/reduce conflict for STRINGS in state 0 resolved as shift
WARNING: shift/reduce conflict for BOOL in state 0 resolved as shift
WARNING: shift/reduce conflict for VOID in state 0 resolved as shift
WARNING: shift/reduce conflict for IDENTIFIER in state 2 resolved as shift
WARNING: shift/reduce conflict for IF in state 2 resolved as shift
WARNING: shift/reduce conflict for FOR in state 2 resolved as shift
WARNING: shift/reduce conflict for PRINTF in state 2 resolved as shift
WARNING: shift/reduce conflict for INT in state 2 resolved as shift
WARNING: shift/reduce conflict for DOUBLE in state 2 resolved as shift
WARNING: shift/reduce conflict for CHARS in state 2 resolved as shift
WARNING: shift/reduce conflict for STRINGS in state 2 resolved as shift
WARNING: shift/reduce conflict for BOOL in state 2 resolved as shift
WARNING: shift/reduce conflict for VOID in state 2 resolved as shift
WARNING: shift/reduce conflict for RPAREN in state 43 resolved as shift
WARNING: shift/reduce conflict for OPERATOR in state 74 resolved as shift
WARNING: shift/reduce conflict for IDENTIFIER in state 84 resolved as shift
WARNING: shift/reduce conflict for IF in state 84 resolved as shift
WARNING: shift/reduce conflict for FOR in state 84 resolved as shift
WARNING: shift/reduce conflict for PRINTF in state 84 resolved as shift
WARNING: shift/reduce conflict for INT in state 84 resolved as shift
WARNING: shift/reduce conflict for DOUBLE in state 84 resolved as shift
WARNING: shift/reduce conflict for CHARS in state 84 resolved as shift
WARNING: shift/reduce conflict for STRINGS in state 84 resolved as shift
WARNING: shift/reduce conflict for BOOL in state 84 resolved as shift
WARNING: shift/reduce conflict for VOID in state 84 resolved as shift
WARNING: shift/reduce conflict for IDENTIFIER in state 85 resolved as shift
WARNING: shift/reduce conflict for IF in state 85 resolved as shift
WARNING: shift/reduce conflict for FOR in state 85 resolved as shift
WARNING: shift/reduce conflict for PRINTF in state 85 resolved as shift
WARNING: shift/reduce conflict for INT in state 85 resolved as shift
WARNING: shift/reduce conflict for DOUBLE in state 85 resolved as shift
WARNING: shift/reduce conflict for CHARS in state 85 resolved as shift
WARNING: shift/reduce conflict for STRINGS in state 85 resolved as shift
WARNING: shift/reduce conflict for BOOL in state 85 resolved as shift
WARNING: shift/reduce conflict for VOID in state 85 resolved as shift
WARNING: shift/reduce conflict for RELATIONALOPERATOR in state 86 resolved as shift
WARNING: shift/reduce conflict for IDENTIFIER in state 87 resolved as shift
WARNING: shift/reduce conflict for IF in state 87 resolved as shift
WARNING: shift/reduce conflict for FOR in state 87 resolved as shift
WARNING: shift/reduce conflict for PRINTF in state 87 resolved as shift
WARNING: shift/reduce conflict for INT in state 87 resolved as shift
WARNING: shift/reduce conflict for DOUBLE in state 87 resolved as shift
WARNING: shift/reduce conflict for CHARS in state 87 resolved as shift
WARNING: shift/reduce conflict for STRINGS in state 87 resolved as shift
WARNING: shift/reduce conflict for BOOL in state 87 resolved as shift
WARNING: shift/reduce conflict for VOID in state 87 resolved as shift
WARNING: shift/reduce conflict for COMMA in state 92 resolved as shift
WARNING: shift/reduce conflict for RBRACE in state 101 resolved as shift
WARNING: shift/reduce conflict for RBRACE in state 101 resolved as shift
WARNING: shift/reduce conflict for IDENTIFIER in state 101 resolved as shift
WARNING: shift/reduce conflict for IF in state 101 resolved as shift
WARNING: shift/reduce conflict for FOR in state 101 resolved as shift
WARNING: shift/reduce conflict for PRINTF in state 101 resolved as shift
WARNING: shift/reduce conflict for INT in state 101 resolved as shift
WARNING: shift/reduce conflict for DOUBLE in state 101 resolved as shift
WARNING: shift/reduce conflict for CHARS in state 101 resolved as shift
WARNING: shift/reduce conflict for STRINGS in state 101 resolved as shift
WARNING: shift/reduce conflict for BOOL in state 101 resolved as shift
WARNING: shift/reduce conflict for VOID in state 101 resolved as shift
WARNING: shift/reduce conflict for IDENTIFIER in state 103 resolved as shift
WARNING: shift/reduce conflict for IF in state 103 resolved as shift
WARNING: shift/reduce conflict for FOR in state 103 resolved as shift
WARNING: shift/reduce conflict for PRINTF in state 103 resolved as shift
WARNING: shift/reduce conflict for INT in state 103 resolved as shift
WARNING: shift/reduce conflict for DOUBLE in state 103 resolved as shift
WARNING: shift/reduce conflict for CHARS in state 103 resolved as shift
WARNING: shift/reduce conflict for STRINGS in state 103 resolved as shift
WARNING: shift/reduce conflict for BOOL in state 103 resolved as shift
WARNING: shift/reduce conflict for VOID in state 103 resolved as shift
WARNING: shift/reduce conflict for COMMA in state 143 resolved as shift
WARNING: shift/reduce conflict for IDENTIFIER in state 147 resolved as shift
WARNING: shift/reduce conflict for IF in state 147 resolved as shift
WARNING: shift/reduce conflict for FOR in state 147 resolved as shift
WARNING: shift/reduce conflict for PRINTF in state 147 resolved as shift
WARNING: shift/reduce conflict for INT in state 147 resolved as shift
WARNING: shift/reduce conflict for DOUBLE in state 147 resolved as shift
WARNING: shift/reduce conflict for CHARS in state 147 resolved as shift
WARNING: shift/reduce conflict for STRINGS in state 147 resolved as shift
WARNING: shift/reduce conflict for BOOL in state 147 resolved as shift
WARNING: shift/reduce conflict for VOID in state 147 resolved as shift
WARNING: shift/reduce conflict for IDENTIFIER in state 154 resolved as shift
WARNING: shift/reduce conflict for IF in state 154 resolved as shift
WARNING: shift/reduce conflict for FOR in state 154 resolved as shift
WARNING: shift/reduce conflict for PRINTF in state 154 resolved as shift
WARNING: shift/reduce conflict for INT in state 154 resolved as shift
WARNING: shift/reduce conflict for DOUBLE in state 154 resolved as shift
WARNING: shift/reduce conflict for CHARS in state 154 resolved as shift
WARNING: shift/reduce conflict for STRINGS in state 154 resolved as shift
WARNING: shift/reduce conflict for BOOL in state 154 resolved as shift
WARNING: shift/reduce conflict for VOID in state 154 resolved as shift
WARNING: reduce/reduce conflict in state 0 resolved using rule (program -> <empty>)
WARNING: rejected rule (statement -> <empty>) in state 0
WARNING: reduce/reduce conflict in state 2 resolved using rule (program -> <empty>)
WARNING: rejected rule (statement -> <empty>) in state 2
WARNING: reduce/reduce conflict in state 84 resolved using rule (statements -> <empty>)
WARNING: rejected rule (statement -> <empty>) in state 84
WARNING: reduce/reduce conflict in state 85 resolved using rule (statements -> <empty>)
WARNING: rejected rule (statement -> <empty>) in state 85
WARNING: reduce/reduce conflict in state 87 resolved using rule (statements -> <empty>)
WARNING: rejected rule (statement -> <empty>) in state 87
WARNING: reduce/reduce conflict in state 92 resolved using rule (exp -> IDENTIFIER)
WARNING: rejected rule (arguments -> IDENTIFIER) in state 92
WARNING: reduce/reduce conflict in state 103 resolved using rule (statements -> <empty>)
WARNING: rejected rule (statement -> <empty>) in state 103
WARNING: reduce/reduce conflict in state 147 resolved using rule (statements -> <empty>)
WARNING: rejected rule (statement -> <empty>) in state 147
WARNING: reduce/reduce conflict in state 154 resolved using rule (statements -> <empty>)
WARNING: rejected rule (statement -> <empty>) in state 154
WARNING: Rule (statement -> <empty>) is never reduced
WARNING: Rule (arguments -> IDENTIFIER) is never reduced
